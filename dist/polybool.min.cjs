"use strict";function t(t,e,s){return t+(e-t)*s}function e(e,s,n){return[t(e[0],s[0],n),t(e[1],s[1],n)]}function s(t,e){const[s,n]=t,[i,o]=e;return!(s[0]>o[0]||n[0]<i[0]||s[1]>o[1]||n[1]<i[1])}Object.defineProperty(exports,"__esModule",{value:!0});class n{}class i extends n{constructor(t=1e-10){super(),this.epsilon=t}snap0(t){return Math.abs(t)<this.epsilon?0:t}snap01(t){return Math.abs(t)<this.epsilon?0:Math.abs(1-t)<this.epsilon?1:t}isCollinear(t,e,s){const n=t[0]-e[0],i=t[1]-e[1],o=e[0]-s[0],r=e[1]-s[1];return Math.abs(n*r-o*i)<this.epsilon}solveCubicNormalized(t,e,s){const n=t/3,i=e/3,o=n*n-i,r=n*(n*n-e/2)+s/2;if(Math.abs(r)<this.epsilon&&Math.abs(o)<this.epsilon)return[-n];const a=n*(n*(4*n*s-i*e)-2*e*s)+4*i*i*i+s*s;if(Math.abs(a)<this.epsilon){const e=Math.sqrt(o);return r>0?[-2*e-t/3,e-t/3]:[-e-t/3,2*e-t/3]}const h=o*o*o,l=r*r;if(l<h){const t=(r<0?-1:1)*Math.sqrt(l/h),e=Math.acos(t),s=-2*Math.sqrt(o);return[s*Math.cos(e/3)-n,s*Math.cos((e+2*Math.PI)/3)-n,s*Math.cos((e-2*Math.PI)/3)-n].sort(((t,e)=>t-e))}{const t=(r<0?1:-1)*Math.pow(Math.abs(r)+Math.sqrt(l-h),1/3);return[t+(Math.abs(t)>=this.epsilon?o/t:0)-n]}}solveCubic(t,e,s,n){if(Math.abs(t)<this.epsilon){if(Math.abs(e)<this.epsilon)return Math.abs(s)<this.epsilon?Math.abs(n)<this.epsilon?[0]:[]:[-n/s];const t=2*e;let i=s*s-4*e*n;return Math.abs(i)<this.epsilon?[-s/t]:i>0?(i=Math.sqrt(i),[(-s+i)/t,(-s-i)/t].sort(((t,e)=>t-e))):[]}return this.solveCubicNormalized(e/t,s/t,n/t)}isEqualVec2(t,e){return Math.abs(t[0]-e[0])<this.epsilon&&Math.abs(t[1]-e[1])<this.epsilon}compareVec2(t,e){return Math.abs(e[0]-t[0])<this.epsilon?Math.abs(e[1]-t[1])<this.epsilon?0:t[1]<e[1]?-1:1:t[0]<e[0]?-1:1}}class o{constructor(t){this.tValues=[],this.geo=t}addArray(t){for(const e of t)this.tValues.push(e);return this}add(t){if((t=this.geo.snap01(t))<0||t>1)return this;for(const e of this.tValues)if(0===this.geo.snap0(t-e))return this;return this.tValues.push(t),this}list(){return this.tValues.sort(((t,e)=>t-e)),this.tValues}}class r{constructor(t,e){this.tValuePairs=[],this.allowOutOfRange=t,this.geo=e}add(t,e){if(t=this.geo.snap01(t),e=this.geo.snap01(e),!this.allowOutOfRange&&(t<0||t>1||e<0||e>1))return this;for(const s of this.tValuePairs)if(0===this.geo.snap0(t-s[0])||0===this.geo.snap0(e-s[1]))return this;return this.tValuePairs.push([t,e]),this}list(){return this.tValuePairs.sort(((t,e)=>t[0]-e[0])),this.tValuePairs}done(){return this.tValuePairs.length<=0?null:{kind:"tValuePairs",tValuePairs:this.list()}}}class a{}class h extends a{constructor(t,e,s){super(),this.p0=t,this.p1=e,this.geo=s}copy(){return new h(this.p0,this.p1,this.geo)}isEqual(t){return this.geo.isEqualVec2(this.p0,t.p0)&&this.geo.isEqualVec2(this.p1,t.p1)}start(){return this.p0}start2(){return this.p1}end2(){return this.p0}end(){return this.p1}setStart(t){this.p0=t}setEnd(t){this.p1=t}point(t){const e=this.p0,s=this.p1;return 0===t?e:1===t?s:[e[0]+(s[0]-e[0])*t,e[1]+(s[1]-e[1])*t]}split(t){if(t.length<=0)return[this];const e=t.map((t=>this.point(t)));e.push(this.p1);const s=[];let n=this.p0;for(const t of e)s.push(new h(n,t,this.geo)),n=t;return s}reverse(){return new h(this.p1,this.p0,this.geo)}boundingBox(){const t=this.p0,e=this.p1;return[[Math.min(t[0],e[0]),Math.min(t[1],e[1])],[Math.max(t[0],e[0]),Math.max(t[1],e[1])]]}pointOn(t){return this.geo.isCollinear(t,this.p0,this.p1)}draw(t){const e=this.p0,s=this.p1;return t.moveTo(e[0],e[1]),t.lineTo(s[0],s[1]),t}}class l extends a{constructor(t,e,s,n,i){super(),this.p0=t,this.p1=e,this.p2=s,this.p3=n,this.geo=i}copy(){return new l(this.p0,this.p1,this.p2,this.p3,this.geo)}isEqual(t){return this.geo.isEqualVec2(this.p0,t.p0)&&this.geo.isEqualVec2(this.p1,t.p1)&&this.geo.isEqualVec2(this.p2,t.p2)&&this.geo.isEqualVec2(this.p3,t.p3)}start(){return this.p0}start2(){return this.p1}end2(){return this.p2}end(){return this.p3}setStart(t){this.p0=t}setEnd(t){this.p3=t}point(t){const e=this.p0,s=this.p1,n=this.p2,i=this.p3;if(0===t)return e;if(1===t)return i;const o=(1-t)*(1-t),r=t*t,a=o*(1-t),h=3*o*t,l=3*r*(1-t),c=r*t;return[e[0]*a+s[0]*h+n[0]*l+i[0]*c,e[1]*a+s[1]*h+n[1]*l+i[1]*c]}split(t){if(t.length<=0)return[this];const s=[],n=(t,n)=>{const[i,o,r,a]=t,h=e(i,o,n),c=e(o,r,n),u=e(r,a,n),p=e(h,c,n),d=e(c,u,n),g=e(p,d,n);return s.push(new l(i,h,p,g,this.geo)),[g,d,u,a]};let i=[this.p0,this.p1,this.p2,this.p3],o=0;for(const e of t)i=n(i,(e-o)/(1-o)),o=e;return s.push(new l(i[0],i[1],i[2],i[3],this.geo)),s}reverse(){return new l(this.p3,this.p2,this.p1,this.p0,this.geo)}getCubicCoefficients(t){const e=this.p0[t],s=this.p1[t],n=this.p2[t];return[this.p3[t]-3*n+3*s-e,3*n-6*s+3*e,3*s-3*e,e]}boundingTValues(){const t=new o(this.geo),e=(e,s,n,i)=>{const o=3*i-9*n+9*s-3*e,r=6*e-12*s+6*n,a=3*s-3*e;if(0===this.geo.snap0(o))t.add(-a/r);else{const e=r*r-4*o*a;if(e>=0){const s=Math.sqrt(e);t.add((-r+s)/(2*o)),t.add((-r-s)/(2*o))}}return t},s=this.p0,n=this.p1,i=this.p2,r=this.p3;return e(s[0],n[0],i[0],r[0]),e(s[1],n[1],i[1],r[1]),t.list()}inflectionTValues(){const t=new o(this.geo);t.addArray(this.boundingTValues());const e=this.p0,s=this.p1,n=this.p2,i=this.p3,r=3*(s[0]-e[0]),a=3*(s[1]-e[1]),h=6*(n[0]-s[0]),l=6*(n[1]-s[1]),c=3*(i[0]-n[0]),u=3*(i[1]-n[1]),p=6*(n[0]-2*s[0]+e[0]),d=6*(n[1]-2*s[1]+e[1]),g=r-h+c,f=a-l+u,m=h-2*r,v=l-2*a,w=6*(i[0]-2*n[0]+s[0])-p,S=6*(i[1]-2*n[1]+s[1])-d,b=g*S-f*w,x=g*d+m*S-f*p-v*w,P=m*d+r*S-v*p-a*w,y=r*d-a*p;for(const e of this.geo.solveCubic(b,x,P,y))t.add(e);return t.list()}boundingBox(){const t=this.p0,e=this.p3,s=[Math.min(t[0],e[0]),Math.min(t[1],e[1])],n=[Math.max(t[0],e[0]),Math.max(t[1],e[1])];for(const t of this.boundingTValues()){const e=this.point(t);s[0]=Math.min(s[0],e[0]),s[1]=Math.min(s[1],e[1]),n[0]=Math.max(n[0],e[0]),n[1]=Math.max(n[1],e[1])}return[s,n]}mapXtoT(t,e=!1){if(0===this.geo.snap0(this.p0[0]-t))return 0;if(0===this.geo.snap0(this.p3[0]-t))return 1;const s=this.p0[0]-t,n=this.p1[0]-t,i=this.p2[0]-t,o=[this.p3[0]-t-3*i+3*n-s,3*i-6*n+3*s,3*n-3*s,s];for(const t of this.geo.solveCubic(o[0],o[1],o[2],o[3])){const e=this.geo.snap01(t);if(e>=0&&e<=1)return t}if(e||t>=Math.min(this.p0[0],this.p3[0])&&t<=Math.max(this.p0[0],this.p3[0]))for(let t=0;t<4;t++){let t=-1;for(let e=0;e<4;e++)0!==o[e]&&(t<0||Math.abs(o[e])<Math.abs(o[t]))&&(t=e);if(t<0)return 0;o[t]=0;for(const t of this.geo.solveCubic(o[0],o[1],o[2],o[3])){const e=this.geo.snap01(t);if(e>=0&&e<=1)return t}}return!1}mapXtoY(t,e=!1){const s=this.mapXtoT(t,e);return!1!==s&&this.point(s)[1]}pointOn(t){if(this.geo.isEqualVec2(this.p0,t)||this.geo.isEqualVec2(this.p3,t))return!0;const e=this.mapXtoY(t[0]);return!1!==e&&0===this.geo.snap0(e-t[1])}toLine(){const t=this.p0,e=this.p1,s=this.p2,n=this.p3;return 0===this.geo.snap0(t[0]-e[0])&&0===this.geo.snap0(t[0]-s[0])&&0===this.geo.snap0(t[0]-n[0])||0===this.geo.snap0(t[1]-e[1])&&0===this.geo.snap0(t[1]-s[1])&&0===this.geo.snap0(t[1]-n[1])?new h(t,n,this.geo):null}draw(t){const e=this.p0,s=this.p1,n=this.p2,i=this.p3;return t.moveTo(e[0],e[1]),t.bezierCurveTo(s[0],s[1],n[0],n[1],i[0],i[1]),t}}function c(t,e){const s=e.p1[0]-e.p0[0],n=e.p1[1]-e.p0[1];return((t[0]-e.p0[0])*s+(t[1]-e.p0[1])*n)/(s*s+n*n)}function u(t,e,s){const n=t.geo,i=t.p0,o=t.p1,a=e.p0,h=e.p1,l=o[0]-i[0],u=o[1]-i[1],p=h[0]-a[0],d=h[1]-a[1],g=l*d-u*p;if(0===n.snap0(g)){if(!n.isCollinear(i,o,a))return null;const s=c(e.p0,t),r=c(e.p1,t),h=n.snap01(Math.min(s,r)),l=n.snap01(Math.max(s,r));if(l<0||h>1)return null;const u=c(t.p0,e),p=c(t.p1,e),d=n.snap01(Math.min(u,p)),g=n.snap01(Math.max(u,p));return g<0||d>1?null:{kind:"tRangePairs",tStart:[Math.max(0,h),Math.max(0,d)],tEnd:[Math.min(1,l),Math.min(1,g)]}}const f=i[0]-a[0],m=i[1]-a[1];return new r(s,n).add((p*m-d*f)/g,(l*m-u*f)/g).done()}function p(t,e,s,n){const i=t.geo,o=t.p0,a=t.p1,h=a[1]-o[1],l=o[0]-a[0];if(0===i.snap0(l)){const t=e.mapXtoT(o[0],!1);if(!1===t)return null;const a=(e.point(t)[1]-o[1])/h,l=new r(s,i);return n?l.add(t,a):l.add(a,t),l.done()}const c=h*o[0]+l*o[1],u=e.getCubicCoefficients(0),p=e.getCubicCoefficients(1),d=h*u[0]+l*p[0],g=h*u[1]+l*p[1],f=h*u[2]+l*p[2],m=h*u[3]+l*p[3]-c,v=i.solveCubic(d,g,f,m),w=new r(s,i);if(0===i.snap0(h))for(const t of v){const e=u[0]*t*t*t+u[1]*t*t+u[2]*t+u[3],s=(o[0]-e)/l;n?w.add(t,s):w.add(s,t)}else for(const t of v){const e=(p[0]*t*t*t+p[1]*t*t+p[2]*t+p[3]-o[1])/h;n?w.add(t,e):w.add(e,t)}return w.done()}function d(t,e,n){const i=t.geo;if(i.isEqualVec2(t.p0,e.p0))return i.isEqualVec2(t.p3,e.p3)?i.isEqualVec2(t.p1,e.p1)&&i.isEqualVec2(t.p2,e.p2)?{kind:"tRangePairs",tStart:[0,0],tEnd:[1,1]}:{kind:"tValuePairs",tValuePairs:[[0,0],[1,1]]}:{kind:"tValuePairs",tValuePairs:[[0,0]]};if(i.isEqualVec2(t.p0,e.p3))return{kind:"tValuePairs",tValuePairs:[[0,1]]};if(i.isEqualVec2(t.p3,e.p0))return{kind:"tValuePairs",tValuePairs:[[1,0]]};if(i.isEqualVec2(t.p3,e.p3))return{kind:"tValuePairs",tValuePairs:[[1,1]]};const o=new r(n,i),a=(t,e,n,r,h,l)=>{if(!s(t.boundingBox(),r.boundingBox()))return;const c=(e+n)/2,u=(h+l)/2;if(0===i.snap0(n-e)&&0===i.snap0(l-h))return void o.add(c,u);const[p,d]=t.split([.5]),[g,f]=r.split([.5]);a(p,e,c,g,h,u),a(d,c,n,g,h,u),a(p,e,c,f,u,l),a(d,c,n,f,u,l)};return a(t,0,1,e,0,1),o.done()}function g(t,e,s){if(t instanceof h){if(e instanceof h)return u(t,e,s);if(e instanceof l)return p(t,e,s,!1)}else if(t instanceof l){if(e instanceof h)return p(e,t,s,!0);if(e instanceof l)return d(t,e,s)}throw new Error("PolyBool: Unknown segment instance in segmentsIntersect")}class f{constructor(t,e=null,s=!1,n=null){var i,o,r;this.otherFill=null,this.id=null!==(i=null==n?void 0:n.segmentId())&&void 0!==i?i:-1,this.data=t,this.myFill={above:null!==(o=null==e?void 0:e.above)&&void 0!==o?o:null,below:null!==(r=null==e?void 0:e.below)&&void 0!==r?r:null},this.closed=s}}class m extends f{}class v extends f{}function w(t,e){if(t instanceof m)return new m(t.data,t.myFill,t.closed,e);if(t instanceof v)return new v(t.data,t.myFill,t.closed,e);throw new Error("PolyBool: Unknown SegmentBool in copySegmentBool")}class S{constructor(t,e,s,n){this.status=null,this.isStart=t,this.p=e,this.seg=s,this.primary=n}}class b{constructor(){this.nodes=[]}remove(t){const e=this.nodes.indexOf(t);e>=0&&this.nodes.splice(e,1)}getIndex(t){return this.nodes.indexOf(t)}isEmpty(){return this.nodes.length<=0}getHead(){return this.nodes[0]}removeHead(){this.nodes.shift()}insertBefore(t,e){this.findTransition(t,e).insert(t)}findTransition(t,e){var s,n;let i=0,o=this.nodes.length;for(;i<o;){const s=i+o>>1;r=this.nodes[s],e(t)-e(r)>0?o=s:i=s+1}var r;return{before:i<=0?null:null!==(s=this.nodes[i-1])&&void 0!==s?s:null,after:null!==(n=this.nodes[i])&&void 0!==n?n:null,insert:t=>(this.nodes.splice(i,0,t),t)}}}class x{constructor(t,e,s=null){this.events=new b,this.status=new b,this.currentPath=[],this.selfIntersection=t,this.geo=e,this.log=s}compareEvents(t,e,s,n,i,o,r,a){const l=this.geo.compareVec2(e,o);return 0!==l?l:n instanceof h&&a instanceof h&&this.geo.isEqualVec2(s,r)?0:t!==i?t?1:-1:this.compareSegments(a,n)}addEvent(t){this.events.insertBefore(t,(e=>e===t?0:this.compareEvents(t.isStart,t.p,t.other.p,t.seg.data,e.isStart,e.p,e.other.p,e.seg.data)))}divideEvent(t,e,s){var n,i;null===(n=this.log)||void 0===n||n.segmentDivide(t.seg,s);const[o,r]=t.seg.data.split([e]);o.setEnd(s),r.setStart(s);const a=r instanceof h?new m(r,t.seg.myFill,t.seg.closed,this.log):r instanceof l?new v(r,t.seg.myFill,t.seg.closed,this.log):null;if(!a)throw new Error("PolyBool: Unknown segment data in divideEvent");return this.events.remove(t.other),t.seg.data=o,null===(i=this.log)||void 0===i||i.segmentChop(t.seg),t.other.p=s,this.addEvent(t.other),this.addSegment(a,t.primary)}beginPath(){this.currentPath=[]}closePath(){for(const t of this.currentPath)t.closed=!0}addSegment(t,e){const s=new S(!0,t.data.start(),t,e),n=new S(!1,t.data.end(),t,e);return s.other=n,n.other=s,this.addEvent(s),this.addEvent(n),s}addLine(t,e,s=!0){const n=this.geo.compareVec2(t,e);if(0===n)return;const i=new m(new h(n<0?t:e,n<0?e:t,this.geo),null,!1,this.log);this.currentPath.push(i),this.addSegment(i,s)}addCurve(t,e,s,n,i=!0){const o=new l(t,e,s,n,this.geo),r=o.split(o.inflectionTValues());for(const t of r){const e=this.geo.compareVec2(t.start(),t.end());if(0===e)continue;const s=t.toLine();if(s)this.addLine(s.p0,s.p1,i);else{const s=new v(e<0?t:t.reverse(),null,!1,this.log);this.currentPath.push(s),this.addSegment(s,i)}}}compareSegments(t,e){let s=t.start(),n=e.start2();const i=e.start();if(e.pointOn(s)){if(s=t.start2(),t instanceof h&&e instanceof h&&e.pointOn(s))return 0;if(e instanceof l&&0===this.geo.snap0(s[0]-i[0])&&0===this.geo.snap0(n[0]-i[0]))return Math.sign(i[1]-s[1])}else{if(e instanceof l){const t=e.mapXtoY(s[0],!0);if(!1!==t)return Math.sign(t-s[1])}if(t instanceof l){const s=g(t,e,!0);if(s&&"tValuePairs"===s.kind)for(const e of s.tValuePairs){const s=this.geo.snap01(e[0]);if(s>0&&s<1){n=t.point(s);break}}}}const[o,r]=s,[a,c]=n,[u,p]=i;return Math.sign((a-o)*(p-r)-(c-r)*(u-o))}statusFindSurrounding(t){return this.status.findTransition(t,(e=>{if(t===e)return 0;const s=this.compareSegments(t.seg.data,e.seg.data);return 0===s?-1:s}))}checkIntersection(t,e){var s;const n=t.seg,i=e.seg;null===(s=this.log)||void 0===s||s.checkIntersection(n,i);const o=g(n.data,i.data,!1);if(null===o)return null;if("tRangePairs"===o.kind){const{tStart:[s,r],tEnd:[a,h]}=o;if(1===s&&1===a&&0===r&&0===h||0===s&&0===a&&1===r&&1===h)return null;if(0===s&&1===a&&0===r&&1===h)return e;const l=n.data.start(),c=n.data.end(),u=i.data.end();return 0===s&&0===r?(1===a?this.divideEvent(e,h,c):this.divideEvent(t,a,u),e):(r>0&&r<1&&(1===a&&1===h||(1===a?this.divideEvent(e,h,c):this.divideEvent(t,a,u)),this.divideEvent(e,r,l)),null)}if("tValuePairs"===o.kind){if(o.tValuePairs.length<=0)return null;let s=o.tValuePairs[0];for(let t=1;t<o.tValuePairs.length&&(0===s[0]&&0===s[1]||0===s[0]&&1===s[1]||1===s[0]&&0===s[1]||1===s[0]&&1===s[1]);t++)s=o.tValuePairs[t];const[r,a]=s,h=0===a?i.data.start():1===a?i.data.end():0===r?n.data.start():1===r?n.data.end():n.data.point(r);return r>0&&r<1&&this.divideEvent(t,r,h),a>0&&a<1&&this.divideEvent(e,a,h),null}throw new Error("PolyBool: Unknown intersection type")}calculate(){var t,e,s,n,i,o,r,a;const h=[];for(;!this.events.isEmpty();){const a=this.events.getHead();if(null===(t=this.log)||void 0===t||t.vert(a.p[0]),a.isStart){null===(e=this.log)||void 0===e||e.segmentNew(a.seg,a.primary);const t=this.statusFindSurrounding(a),r=t.before,h=t.after;null===(s=this.log)||void 0===s||s.tempStatus(a.seg,!!r&&r.seg,!!h&&h.seg);const l=()=>{if(r){const t=this.checkIntersection(a,r);if(t)return t}return h?this.checkIntersection(a,h):null},c=l();if(c){if(this.selfIntersection){let t;t=null===a.seg.myFill.below?a.seg.closed:a.seg.myFill.above!==a.seg.myFill.below,t&&(c.seg.myFill.above=!c.seg.myFill.above)}else c.seg.otherFill=a.seg.myFill;null===(n=this.log)||void 0===n||n.segmentUpdate(c.seg),this.events.remove(a.other),this.events.remove(a)}if(this.events.getHead()!==a){null===(i=this.log)||void 0===i||i.rewind(a.seg);continue}if(this.selfIntersection){let t;t=null===a.seg.myFill.below?a.seg.closed:a.seg.myFill.above!==a.seg.myFill.below,a.seg.myFill.below=!!h&&h.seg.myFill.above,a.seg.myFill.above=t?!a.seg.myFill.below:a.seg.myFill.below}else if(null===a.seg.otherFill){let t;if(h)if(a.primary===h.primary){if(null===h.seg.otherFill)throw new Error("PolyBool: Unexpected state of otherFill (null)");t=h.seg.otherFill.above}else t=h.seg.myFill.above;else t=!1;a.seg.otherFill={above:t,below:t}}null===(o=this.log)||void 0===o||o.status(a.seg,!!r&&r.seg,!!h&&h.seg),a.other.status=t.insert(a)}else{const t=a.status;if(null===t)throw new Error("PolyBool: Zero-length segment detected; your epsilon is probably too small or too large");const e=this.status.getIndex(t);if(e>0&&e<this.status.nodes.length-1){const t=this.status.nodes[e-1],s=this.status.nodes[e+1];this.checkIntersection(t,s)}if(null===(r=this.log)||void 0===r||r.statusRemove(t.seg),this.status.remove(t),!a.primary){if(!a.seg.otherFill)throw new Error("PolyBool: Unexpected state of otherFill (null)");const t=a.seg.myFill;a.seg.myFill=a.seg.otherFill,a.seg.otherFill=t}h.push(a.seg)}this.events.removeHead()}return null===(a=this.log)||void 0===a||a.done(),h}}function P(t,e,s){const n=[];for(const i of t){const t=e[(i.myFill.above?8:0)+(i.myFill.below?4:0)+(i.otherFill&&i.otherFill.above?2:0)+(i.otherFill&&i.otherFill.below?1:0)],o=!!(1&t),r=!!(2&t);if(!i.closed&&0!==t||i.closed&&o!==r){const t={above:o,below:r};if(i instanceof m)n.push(new m(i.data,t,i.closed,s));else{if(!(i instanceof v))throw new Error("PolyBool: Unknown SegmentBool type in SegmentSelector");n.push(new v(i.data,t,i.closed,s))}}}return null==s||s.selected(n),n}class y{static union(t,e){return P(t,[4,2,1,0,2,2,0,0,1,0,1,0,0,0,0,0],e)}static intersect(t,e){return P(t,[0,0,0,4,0,2,0,2,0,0,1,1,4,2,1,0],e)}static difference(t,e){return P(t,[4,0,0,0,2,0,2,0,1,1,0,0,0,1,2,0],e)}static differenceRev(t,e){return P(t,[4,2,1,0,0,0,1,1,0,2,0,2,0,0,0,0],e)}static xor(t,e){return P(t,[4,2,1,0,2,0,0,1,1,0,0,2,0,1,2,0],e)}}function M(t,e,s){return!!s.isCollinear(t.p0,t.p1,e.p1)&&new h(t.p0,e.p1,s)}function E(t,e,s){if(s.isCollinear(t.p2,t.p3,e.p1)){const n=e.p1[0]-t.p2[0],i=e.p1[1]-t.p2[1],o=Math.abs(n)>Math.abs(i)?(t.p3[0]-t.p2[0])/n:(t.p3[1]-t.p2[1])/i,r=s.snap01(o);if(0!==r&&1!==r){const n=new l(t.p0,[t.p0[0]+(t.p1[0]-t.p0[0])/o,t.p0[1]+(t.p1[1]-t.p0[1])/o],[e.p2[0]-o*(e.p3[0]-e.p2[0])/(1-o),e.p2[1]-o*(e.p3[1]-e.p2[1])/(1-o)],e.p3,s),[i,r]=n.split([o]);if(i.isEqual(t)&&r.isEqual(e))return n}}return!1}function V(t,e,s){return t!==e&&(t instanceof h&&e instanceof h?M(t,e,s):t instanceof l&&e instanceof l&&E(t,e,s))}function T(t,e,s){const n=[],i=[],o=[];for(const r of t){let a=r.data;const l=r.closed,c=l?n:i,u=a.start(),p=a.end();if(a instanceof h&&e.isEqualVec2(u,p)){console.warn("PolyBool: Warning: Zero-length segment detected; your epsilon is probably too small or too large");continue}null==s||s.chainStart(a,l);const d={index:0,matchesHead:!1,matchesPt1:!1},g={index:0,matchesHead:!1,matchesPt1:!1};let f=d;function m(t,e,s){return f&&(f.index=t,f.matchesHead=e,f.matchesPt1=s),f===d?(f=g,!1):(f=null,!0)}for(let v=0;v<c.length;v++){const w=c[v],S=w[0].start(),b=w[w.length-1].end();if(e.isEqualVec2(S,u)){if(m(v,!0,!0))break}else if(e.isEqualVec2(S,p)){if(m(v,!0,!1))break}else if(e.isEqualVec2(b,u)){if(m(v,!1,!0))break}else if(e.isEqualVec2(b,p)&&m(v,!1,!1))break}if(f===d)null==s||s.chainNew(a,l),c.push([a]);else if(f===g){const x=d.index;null==s||s.chainMatch(x,l);const P=c[x];if(d.matchesHead?d.matchesPt1?(a=a.reverse(),null==s||s.chainAddHead(x,a,l),P.unshift(a)):(null==s||s.chainAddHead(x,a,l),P.unshift(a)):d.matchesPt1?(null==s||s.chainAddTail(x,a,l),P.push(a)):(a=a.reverse(),null==s||s.chainAddTail(x,a,l),P.push(a)),d.matchesHead){const y=P[1],M=V(a,y,e);M&&(null==s||s.chainSimplifyHead(x,M,l),P.shift(),P[0]=M)}else{const E=V(P[P.length-2],a,e);E&&(null==s||s.chainSimplifyTail(x,E,l),P.pop(),P[P.length-1]=E)}if(l){const T=P[0],C=P[P.length-1];if(P.length>0&&e.isEqualVec2(T.start(),C.end())){const B=V(C,T,e);B&&(null==s||s.chainSimplifyClose(x,B,l),P.pop(),P[0]=B),null==s||s.chainClose(x,l),c.splice(x,1),o.push(P)}}}else{function q(t){null==s||s.chainReverse(t,l);const e=[];for(const s of c[t])e.unshift(s.reverse());c[t]=e}function F(t,n){const i=c[t],o=c[n];null==s||s.chainAddTail(t,a,l),i.push(a);const r=V(i[i.length-2],a,e);r&&(null==s||s.chainSimplifyTail(t,r,l),i.pop(),i[i.length-1]=r);const h=V(i[i.length-1],o[0],e);h&&(null==s||s.chainSimplifyJoin(t,n,h,l),o.shift(),i[i.length-1]=h),null==s||s.chainJoin(t,n,l),c[t]=i.concat(o),c.splice(n,1)}const k=d.index,I=g.index;null==s||s.chainConnect(k,I,l);const _=c[k].length<c[I].length;d.matchesHead?g.matchesHead?_?(d.matchesPt1||(a=a.reverse()),q(k),F(k,I)):(d.matchesPt1&&(a=a.reverse()),q(I),F(I,k)):(d.matchesPt1&&(a=a.reverse()),F(I,k)):g.matchesHead?(d.matchesPt1||(a=a.reverse()),F(k,I)):_?(d.matchesPt1&&(a=a.reverse()),q(k),F(I,k)):(d.matchesPt1||(a=a.reverse()),q(I),F(k,I))}}for(const R of i)o.push(R);return o}function C(t,e,s){for(const n of t){if(n.length<=0)continue;s.beginPath();for(let t=0;t<n.length;t++){const e=n[t];if(0===t){const t=e.start();s.moveTo(t[0],t[1])}if(e instanceof h)s.lineTo(e.p1[0],e.p1[1]);else{if(!(e instanceof l))throw new Error("PolyBool: Unknown segment instance");s.bezierCurveTo(e.p1[0],e.p1[1],e.p2[0],e.p2[1],e.p3[0],e.p3[1])}}const t=n[0],i=n[n.length-1];e.isEqualVec2(t.start(),i.end())&&s.closePath()}return s}class B{constructor(t,e=null,s=null){this.pathState={kind:"beginPath"},this.saveStack=[],this.matrix=[1,0,0,1,0,0],this.geo=t,this.log=s,this.resultState=e?{state:"seg",segments:e}:{state:"new",selfIntersect:new x(!0,this.geo,this.log)}}setTransform(t,e,s,n,i,o){if("new"!==this.resultState.state)throw new Error("PolyBool: Cannot change shape after using it in an operation");return this.matrix=[t,e,s,n,i,o],this}resetTransform(){return this.matrix=[1,0,0,1,0,0],this}getTransform(){if("new"!==this.resultState.state)throw new Error("PolyBool: Cannot change shape after using it in an operation");const[t,e,s,n,i,o]=this.matrix;return{a:t,b:e,c:s,d:n,e:i,f:o}}transform(t,e,s,n,i,o){const[r,a,h,l,c,u]=this.matrix;return this.matrix=[r*t+h*e,a*t+l*e,r*s+h*n,a*s+l*n,r*i+h*o+c,a*i+l*o+u],this}rotate(t){const e=Math.cos(t),s=Math.sin(t),[n,i,o,r,a,h]=this.matrix;return this.matrix=[n*e+o*s,i*e+r*s,o*e-n*s,r*e-i*s,a,h],this}rotateDeg(t){const e=(t%360+360)%360;if(0===e)return this;let s=0,n=0;if(90===e)n=1;else if(180===e)s=-1;else if(270===e)n=-1;else if(45===e)s=n=Math.SQRT1_2;else if(135===e)n=Math.SQRT1_2,s=-Math.SQRT1_2;else if(225===e)s=n=-Math.SQRT1_2;else if(315===e)s=Math.SQRT1_2,n=-Math.SQRT1_2;else if(30===e)s=Math.sqrt(3)/2,n=.5;else if(60===e)s=.5,n=Math.sqrt(3)/2;else if(120===e)s=-.5,n=Math.sqrt(3)/2;else if(150===e)s=-Math.sqrt(3)/2,n=.5;else if(210===e)s=-Math.sqrt(3)/2,n=-.5;else if(240===e)s=-.5,n=-Math.sqrt(3)/2;else if(300===e)s=.5,n=-Math.sqrt(3)/2;else if(330===e)s=Math.sqrt(3)/2,n=-.5;else{const t=Math.PI*e/180;s=Math.cos(t),n=Math.sin(t)}const[i,o,r,a,h,l]=this.matrix;return this.matrix=[i*s+r*n,o*s+a*n,r*s-i*n,a*s-o*n,h,l],this}scale(t,e){const[s,n,i,o,r,a]=this.matrix;return this.matrix=[s*t,n*t,i*e,o*e,r,a],this}translate(t,e){const[s,n,i,o,r,a]=this.matrix;return this.matrix=[s,n,i,o,s*t+i*e+r,n*t+o*e+a],this}save(){if("new"!==this.resultState.state)throw new Error("PolyBool: Cannot change shape after using it in an operation");return this.saveStack.push({matrix:this.matrix}),this}restore(){if("new"!==this.resultState.state)throw new Error("PolyBool: Cannot change shape after using it in an operation");const t=this.saveStack.pop();return t&&(this.matrix=t.matrix),this}transformPoint(t,e){const[s,n,i,o,r,a]=this.matrix;return[s*t+i*e+r,n*t+o*e+a]}beginPath(){if("new"!==this.resultState.state)throw new Error("PolyBool: Cannot change shape after using it in an operation");return this.resultState.selfIntersect.beginPath(),this.endPath()}moveTo(t,e){if("new"!==this.resultState.state)throw new Error("PolyBool: Cannot change shape after using it in an operation");"beginPath"!==this.pathState.kind&&this.beginPath();const s=this.transformPoint(t,e);return this.pathState={kind:"moveTo",start:s,current:s},this}lineTo(t,e){if("new"!==this.resultState.state)throw new Error("PolyBool: Cannot change shape after using it in an operation");if("moveTo"!==this.pathState.kind)throw new Error("PolyBool: Must call moveTo prior to calling lineTo");const s=this.transformPoint(t,e);return this.resultState.selfIntersect.addLine(this.pathState.current,s),this.pathState.current=s,this}bezierCurveTo(t,e,s,n,i,o){if("new"!==this.resultState.state)throw new Error("PolyBool: Cannot change shape after using it in an operation");if("moveTo"!==this.pathState.kind)throw new Error("PolyBool: Must call moveTo prior to calling bezierCurveTo");const r=this.transformPoint(i,o);return this.resultState.selfIntersect.addCurve(this.pathState.current,this.transformPoint(t,e),this.transformPoint(s,n),r),this.pathState.current=r,this}closePath(){if("new"!==this.resultState.state)throw new Error("PolyBool: Cannot change shape after using it in an operation");return"moveTo"!==this.pathState.kind||this.geo.isEqualVec2(this.pathState.start,this.pathState.current)||(this.resultState.selfIntersect.addLine(this.pathState.current,this.pathState.start),this.pathState.current=this.pathState.start),this.resultState.selfIntersect.closePath(),this.endPath()}endPath(){if("new"!==this.resultState.state)throw new Error("PolyBool: Cannot change shape after using it in an operation");return this.pathState={kind:"beginPath"},this}selfIntersect(){return"new"===this.resultState.state&&(this.resultState={state:"seg",segments:this.resultState.selfIntersect.calculate()}),this.resultState.segments}segments(){if("reg"!==this.resultState.state){const t=this.selfIntersect();this.resultState={state:"reg",segments:t,regions:T(t,this.geo,this.log)}}return this.resultState.regions}output(t){return C(this.segments(),this.geo,t)}combine(t){const e=new x(!1,this.geo,this.log);for(const t of this.selfIntersect())e.addSegment(w(t,this.log),!0);for(const s of t.selfIntersect())e.addSegment(w(s,this.log),!1);return new q(e.calculate(),this.geo,this.log)}}class q{constructor(t,e,s=null){this.geo=e,this.segments=t,this.log=s}union(){return new B(this.geo,y.union(this.segments,this.log),this.log)}intersect(){return new B(this.geo,y.intersect(this.segments,this.log),this.log)}difference(){return new B(this.geo,y.difference(this.segments,this.log),this.log)}differenceRev(){return new B(this.geo,y.differenceRev(this.segments,this.log),this.log)}xor(){return new B(this.geo,y.xor(this.segments,this.log),this.log)}}class F{constructor(){this.list=[],this.nextSegmentId=0,this.curVert=NaN}push(t,e){this.list.push({type:t,data:JSON.parse(JSON.stringify(e))})}info(t,e){this.push("info",{msg:t,data:e})}segmentId(){return this.nextSegmentId++}checkIntersection(t,e){this.push("check",{seg1:t,seg2:e})}segmentDivide(t,e){this.push("div_seg",{seg:t,p:e})}segmentChop(t){this.push("chop",{seg:t})}statusRemove(t){this.push("pop_seg",{seg:t})}segmentUpdate(t){this.push("seg_update",{seg:t})}segmentNew(t,e){this.push("new_seg",{seg:t,primary:e})}tempStatus(t,e,s){this.push("temp_status",{seg:t,above:e,below:s})}rewind(t){this.push("rewind",{seg:t})}status(t,e,s){this.push("status",{seg:t,above:e,below:s})}vert(t){t!==this.curVert&&(this.push("vert",{x:t}),this.curVert=t)}selected(t){this.push("selected",{segs:t})}chainStart(t,e){this.push("chain_start",{seg:t,closed:e})}chainNew(t,e){this.push("chain_new",{seg:t,closed:e})}chainMatch(t,e){this.push("chain_match",{index:t,closed:e})}chainClose(t,e){this.push("chain_close",{index:t,closed:e})}chainAddHead(t,e,s){this.push("chain_add_head",{index:t,seg:e,closed:s})}chainAddTail(t,e,s){this.push("chain_add_tail",{index:t,seg:e,closed:s})}chainSimplifyHead(t,e,s){this.push("chain_simp_head",{index:t,seg:e,closed:s})}chainSimplifyTail(t,e,s){this.push("chain_simp_tail",{index:t,seg:e,closed:s})}chainSimplifyClose(t,e,s){this.push("chain_simp_close",{index:t,seg:e,closed:s})}chainSimplifyJoin(t,e,s,n){this.push("chain_simp_join",{index1:t,index2:e,seg:s,closed:n})}chainConnect(t,e,s){this.push("chain_con",{index1:t,index2:e,closed:s})}chainReverse(t,e){this.push("chain_rev",{index:t,closed:e})}chainJoin(t,e,s){this.push("chain_join",{index1:t,index2:e,closed:s})}done(){this.push("done",null)}}class k{constructor(t=new i,e=null){this.geo=t,this.log=e}shape(){return new B(this.geo,null,this.log)}buildLog(t){var e;return this.log=t?new F:null,null===(e=this.log)||void 0===e?void 0:e.list}segments(t){const e=this.shape();for(const s of t.regions){e.beginPath();const t=s[s.length-1];e.moveTo(t[t.length-2],t[t.length-1]);for(const t of s)if(2===t.length)e.lineTo(t[0],t[1]);else{if(6!==t.length)throw new Error("PolyBool: Invalid point in region");e.bezierCurveTo(t[0],t[1],t[2],t[3],t[4],t[5])}e.closePath()}return{shape:e,inverted:t.inverted}}combine(t,e){return{shape:t.shape.combine(e.shape),inverted1:t.inverted,inverted2:e.inverted}}selectUnion(t){return{shape:t.inverted1?t.inverted2?t.shape.intersect():t.shape.difference():t.inverted2?t.shape.differenceRev():t.shape.union(),inverted:t.inverted1||t.inverted2}}selectIntersect(t){return{shape:t.inverted1?t.inverted2?t.shape.union():t.shape.differenceRev():t.inverted2?t.shape.difference():t.shape.intersect(),inverted:t.inverted1&&t.inverted2}}selectDifference(t){return{shape:t.inverted1?t.inverted2?t.shape.differenceRev():t.shape.union():t.inverted2?t.shape.intersect():t.shape.difference(),inverted:t.inverted1&&!t.inverted2}}selectDifferenceRev(t){return{shape:t.inverted1?t.inverted2?t.shape.difference():t.shape.intersect():t.inverted2?t.shape.union():t.shape.differenceRev(),inverted:!t.inverted1&&t.inverted2}}selectXor(t){return{shape:t.shape.xor(),inverted:t.inverted1!==t.inverted2}}polygon(t){const e=[],s={beginPath:()=>{e.push([])},moveTo:()=>{},lineTo:(t,s)=>{e[e.length-1].push([t,s])},bezierCurveTo:(t,s,n,i,o,r)=>{e[e.length-1].push([t,s,n,i,o,r])},closePath:()=>{}};return t.shape.output(s),{regions:e,inverted:t.inverted}}union(t,e){const s=this.segments(t),n=this.segments(e),i=this.combine(s,n),o=this.selectUnion(i);return this.polygon(o)}intersect(t,e){const s=this.segments(t),n=this.segments(e),i=this.combine(s,n),o=this.selectIntersect(i);return this.polygon(o)}difference(t,e){const s=this.segments(t),n=this.segments(e),i=this.combine(s,n),o=this.selectDifference(i);return this.polygon(o)}differenceRev(t,e){const s=this.segments(t),n=this.segments(e),i=this.combine(s,n),o=this.selectDifferenceRev(i);return this.polygon(o)}xor(t,e){const s=this.segments(t),n=this.segments(e),i=this.combine(s,n),o=this.selectXor(i);return this.polygon(o)}}const I=new k;exports.EventBool=S,exports.Geometry=n,exports.GeometryEpsilon=i,exports.Intersecter=x,exports.ListBool=b,exports.PolyBool=k,exports.SegmentBase=a,exports.SegmentBoolBase=f,exports.SegmentBoolCurve=v,exports.SegmentBoolLine=m,exports.SegmentChainer=T,exports.SegmentCurve=l,exports.SegmentLine=h,exports.SegmentSelector=y,exports.SegmentTValuePairsBuilder=r,exports.SegmentTValuesBuilder=o,exports.Shape=B,exports.ShapeCombined=q,exports.boundingBoxesIntersect=s,exports.copySegmentBool=w,exports.default=I,exports.joinCurves=E,exports.joinLines=M,exports.joinSegments=V,exports.lerp=t,exports.lerpVec2=e,exports.projectPointOntoSegmentLine=c,exports.segmentCurveIntersectSegmentCurve=d,exports.segmentLineIntersectSegmentCurve=p,exports.segmentLineIntersectSegmentLine=u,exports.segmentsIntersect=g,exports.segmentsToReceiver=C;
