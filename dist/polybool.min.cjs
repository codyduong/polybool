"use strict";function t(t,e,s){return t+(e-t)*s}function e(e,s,n){return[t(e[0],s[0],n),t(e[1],s[1],n)]}Object.defineProperty(exports,"__esModule",{value:!0});class s{}class n extends s{constructor(t=1e-10){super(),this.epsilon=t}snap0(t){return Math.abs(t)<this.epsilon?0:t}snap01(t){return Math.abs(t)<this.epsilon?0:Math.abs(1-t)<this.epsilon?1:t}atan2deg(t,e){return Math.abs(t)<this.epsilon?e>0||Math.abs(e)<this.epsilon?0:180:Math.abs(e)<this.epsilon?t<0?270:90:Math.abs(e-t)<this.epsilon?e<0?225:45:Math.abs(e+t)<this.epsilon?e<0?315:135:(180*Math.atan2(t,e)/Math.PI+360)%360}isCollinear(t,e,s){const n=t[0]-e[0],i=t[1]-e[1],o=e[0]-s[0],r=e[1]-s[1];return Math.abs(n*r-o*i)<this.epsilon}solveCubic(t,e,s,n){const i=2*e,o=t*t,r=o*t;if(Math.abs(r)<this.epsilon){if(Math.abs(e)<this.epsilon)return Math.abs(s)<this.epsilon?Math.abs(n)<this.epsilon?[0]:[]:[-n/s];let t=s*s-4*e*n;return Math.abs(t)<this.epsilon?[-s/i]:t>0?(t=Math.sqrt(t),i<0?[(-s+t)/i,(-s-t)/i]:[(-s-t)/i,(-s+t)/i]):[]}const a=e*e;let h=(3*t*s-a)/(3*o);const l=(a*i-9*t*e*s+27*o*n)/(27*r),c=-e/(3*t);if(Math.abs(h)<this.epsilon)return[c+Math.cbrt(-l)];if(Math.abs(l)<this.epsilon)return h<0?(h=Math.sqrt(-h),[c-h,c,c+h]):[c];const u=l*l/4+h*h*h/27;if(Math.abs(u)<this.epsilon){const t=l/h;return t<0?[c+3*t,c-1.5*t]:[c-1.5*t,c+3*t]}if(u>0){const t=Math.cbrt(-l/2-Math.sqrt(u));return[c+t-h/(3*t)]}const p=2*Math.sqrt(-h/3),d=Math.acos(3*l/h/p)/3,g=2*Math.PI/3;return[c+p*Math.cos(d-2*g),c+p*Math.cos(d-g),c+p*Math.cos(d)]}isEqualVec2(t,e){return Math.abs(t[0]-e[0])<this.epsilon&&Math.abs(t[1]-e[1])<this.epsilon}compareVec2(t,e){return Math.abs(e[0]-t[0])<this.epsilon?Math.abs(e[1]-t[1])<this.epsilon?0:t[1]<e[1]?-1:1:t[0]<e[0]?-1:1}}class i{constructor(t){this.tValues=[],this.geo=t}addArray(t){for(const e of t)this.tValues.push(e);return this}add(t){if((t=this.geo.snap01(t))<0||t>1)return this;for(const e of this.tValues)if(0===this.geo.snap0(t-e))return this;return this.tValues.push(t),this}list(){return this.tValues.sort(((t,e)=>t-e)),this.tValues}}class o{constructor(t,e){this.tValuePairs=[],this.allowOutOfRange=t,this.geo=e}add(t,e){if(t=this.geo.snap01(t),e=this.geo.snap01(e),!this.allowOutOfRange&&(t<0||t>1||e<0||e>1))return this;for(const s of this.tValuePairs)if(0===this.geo.snap0(t-s[0])||0===this.geo.snap0(e-s[1]))return this;return this.tValuePairs.push([t,e]),this}list(){return this.tValuePairs.sort(((t,e)=>t[0]-e[0])),this.tValuePairs}done(){return this.tValuePairs.length<=0?null:{kind:"tValuePairs",tValuePairs:this.list()}}}class r{}class a extends r{constructor(t,e,s){super(),this.p0=t,this.p1=e,this.geo=s}start(){return this.p0}start2(){return this.p1}end(){return this.p1}setStart(t){this.p0=t}setEnd(t){this.p1=t}point(t){const e=this.p0,s=this.p1;return 0===t?e:1===t?s:[e[0]+(s[0]-e[0])*t,e[1]+(s[1]-e[1])*t]}tangentStart(){const t=this.p0,e=this.p1;return this.geo.atan2deg(e[1]-t[1],e[0]-t[0])}tangentEnd(){const t=this.p0,e=this.p1;return this.geo.atan2deg(e[1]-t[1],e[0]-t[0])}split(t){if(t.length<=0)return[this];const e=t.map((t=>this.point(t)));e.push(this.p1);const s=[];let n=this.p0;for(const t of e)s.push(new a(n,t,this.geo)),n=t;return s}reverse(){return new a(this.p1,this.p0,this.geo)}boundingBox(){const t=this.p0,e=this.p1;return[[Math.min(t[0],e[0]),Math.min(t[1],e[1])],[Math.max(t[0],e[0]),Math.max(t[1],e[1])]]}pointOn(t){return this.geo.isCollinear(t,this.p0,this.p1)}draw(t){const e=this.p0,s=this.p1;t.moveTo(e[0],e[1]),t.lineTo(s[0],s[1])}}class h extends r{constructor(t,e,s,n,i){super(),this.p0=t,this.p1=e,this.p2=s,this.p3=n,this.geo=i}start(){return this.p0}start2(){return this.p1}end(){return this.p3}setStart(t){this.p0=t}setEnd(t){this.p3=t}point(t){const e=this.p0,s=this.p1,n=this.p2,i=this.p3;if(0===t)return e;if(1===t)return i;const o=(1-t)*(1-t),r=t*t,a=o*(1-t),h=3*o*t,l=3*r*(1-t),c=r*t;return[e[0]*a+s[0]*h+n[0]*l+i[0]*c,e[1]*a+s[1]*h+n[1]*l+i[1]*c]}tangentStart(){const t=this.p0,e=this.p1;return this.geo.atan2deg(e[1]-t[1],e[0]-t[0])}tangentEnd(){const t=this.p2,e=this.p3;return this.geo.atan2deg(e[1]-t[1],e[0]-t[0])}split(t){if(t.length<=0)return[this];const s=[],n=(t,n)=>{const[i,o,r,a]=t,l=e(i,o,n),c=e(o,r,n),u=e(r,a,n),p=e(l,c,n),d=e(c,u,n),g=e(p,d,n);return s.push(new h(i,l,p,g,this.geo)),[g,d,u,a]};let i=[this.p0,this.p1,this.p2,this.p3],o=0;for(const e of t)i=n(i,(e-o)/(1-o)),o=e;return s.push(new h(i[0],i[1],i[2],i[3],this.geo)),s}reverse(){return new h(this.p3,this.p2,this.p1,this.p0,this.geo)}getCubicCoefficients(t){const e=this.p0[t],s=this.p1[t],n=this.p2[t];return[this.p3[t]-3*n+3*s-e,3*n-6*s+3*e,3*s-3*e,e]}boundingTValues(){const t=new i(this.geo),e=(e,s,n,i)=>{const o=3*i-9*n+9*s-3*e,r=6*e-12*s+6*n,a=3*s-3*e;if(0===this.geo.snap0(o))t.add(-a/r);else{const e=r*r-4*o*a;if(e>=0){const s=Math.sqrt(e);t.add((-r+s)/(2*o)),t.add((-r-s)/(2*o))}}return t},s=this.p0,n=this.p1,o=this.p2,r=this.p3;return e(s[0],n[0],o[0],r[0]),e(s[1],n[1],o[1],r[1]),t.list()}inflectionTValues(){const t=new i(this.geo);t.addArray(this.boundingTValues());const e=this.p0,s=this.p1,n=this.p2,o=this.p3,r=3*(s[0]-e[0]),a=3*(s[1]-e[1]),h=6*(n[0]-s[0]),l=6*(n[1]-s[1]),c=3*(o[0]-n[0]),u=3*(o[1]-n[1]),p=6*(n[0]-2*s[0]+e[0]),d=6*(n[1]-2*s[1]+e[1]),g=r-h+c,f=a-l+u,m=h-2*r,v=l-2*a,w=6*(o[0]-2*n[0]+s[0])-p,b=6*(o[1]-2*n[1]+s[1])-d,S=g*b-f*w,y=g*d+m*b-f*p-v*w,P=m*d+r*b-v*p-a*w,x=r*d-a*p;for(const e of this.geo.solveCubic(S,y,P,x))t.add(e);return t.list()}boundingBox(){const t=this.p0,e=this.p3,s=[Math.min(t[0],e[0]),Math.min(t[1],e[1])],n=[Math.max(t[0],e[0]),Math.max(t[1],e[1])];for(const t of this.boundingTValues()){const e=this.point(t);s[0]=Math.min(s[0],e[0]),s[1]=Math.min(s[1],e[1]),n[0]=Math.max(n[0],e[0]),n[1]=Math.max(n[1],e[1])}return[s,n]}mapXtoY(t){if(0===this.geo.snap0(this.p0[0]-t))return this.p0[1];if(0===this.geo.snap0(this.p3[0]-t))return this.p3[1];const e=this.p0[0]-t,s=this.p1[0]-t,n=this.p2[0]-t,i=this.p3[0]-t-3*n+3*s-e,o=3*n-6*s+3*e,r=3*s-3*e,a=e,h=this.geo.solveCubic(i,o,r,a);for(const t of h){const e=this.geo.snap01(t);if(e>=0&&e<=1)return this.point(t)[1]}return!1}pointOn(t){if(this.geo.isEqualVec2(this.p0,t)||this.geo.isEqualVec2(this.p3,t))return!0;const e=this.mapXtoY(t[0]);return!1!==e&&0===this.geo.snap0(e-t[1])}toLine(){const t=this.p0,e=this.p1,s=this.p2,n=this.p3;return 0===this.geo.snap0(t[0]-e[0])&&0===this.geo.snap0(t[0]-s[0])&&0===this.geo.snap0(t[0]-n[0])||0===this.geo.snap0(t[1]-e[1])&&0===this.geo.snap0(t[1]-s[1])&&0===this.geo.snap0(t[1]-n[1])?new a(t,n,this.geo):null}draw(t){const e=this.p0,s=this.p1,n=this.p2,i=this.p3;t.moveTo(e[0],e[1]),t.bezierCurveTo(s[0],s[1],n[0],n[1],i[0],i[1])}}function l(t,e){const s=e.p1[0]-e.p0[0],n=e.p1[1]-e.p0[1];return((t[0]-e.p0[0])*s+(t[1]-e.p0[1])*n)/(s*s+n*n)}function c(t,e,s){const n=t.geo,i=t.p0,r=t.p1,a=e.p0,h=e.p1,c=r[0]-i[0],u=r[1]-i[1],p=h[0]-a[0],d=h[1]-a[1],g=c*d-u*p;if(0===n.snap0(g)){if(!n.isCollinear(i,r,a))return null;const s=l(e.p0,t),o=l(e.p1,t),h=n.snap01(Math.min(s,o)),c=n.snap01(Math.max(s,o));if(c<0||h>1)return null;const u=l(t.p0,e),p=l(t.p1,e),d=n.snap01(Math.min(u,p)),g=n.snap01(Math.max(u,p));return g<0||d>1?null:{kind:"tRangePairs",tStart:[Math.max(0,h),Math.max(0,d)],tEnd:[Math.min(1,c),Math.min(1,g)]}}const f=i[0]-a[0],m=i[1]-a[1];return new o(s,n).add((p*m-d*f)/g,(c*m-u*f)/g).done()}function u(t,e,s,n){const i=t.geo,r=t.p0,a=t.p1,h=a[1]-r[1],l=r[0]-a[0],c=h*r[0]+l*r[1],u=e.getCubicCoefficients(0),p=e.getCubicCoefficients(1),d=i.solveCubic(h*u[0]+l*p[0],h*u[1]+l*p[1],h*u[2]+l*p[2],h*u[3]+l*p[3]-c),g=new o(s,i);if(0===i.snap0(h))for(const t of d){const e=u[0]*t*t*t+u[1]*t*t+u[2]*t+u[3],s=(r[0]-e)/l;n?g.add(t,s):g.add(s,t)}else for(const t of d){const e=(p[0]*t*t*t+p[1]*t*t+p[2]*t+p[3]-r[1])/h;n?g.add(t,e):g.add(e,t)}return g.done()}function p(t,e,s){const n=t.geo;if(n.isEqualVec2(t.p0,e.p0))return n.isEqualVec2(t.p3,e.p3)?n.isEqualVec2(t.p1,e.p1)&&n.isEqualVec2(t.p2,e.p2)?{kind:"tRangePairs",tStart:[0,0],tEnd:[1,1]}:{kind:"tValuePairs",tValuePairs:[[0,0],[1,1]]}:{kind:"tValuePairs",tValuePairs:[[0,0]]};if(n.isEqualVec2(t.p0,e.p3))return{kind:"tValuePairs",tValuePairs:[[0,1]]};if(n.isEqualVec2(t.p3,e.p0))return{kind:"tValuePairs",tValuePairs:[[1,0]]};if(n.isEqualVec2(t.p3,e.p3))return{kind:"tValuePairs",tValuePairs:[[1,1]]};const i=new o(s,n),r=(t,e,s,o,a,h)=>{if(!function(t,e){const[s,n]=t,[i,o]=e;return!(s[0]>o[0]||n[0]<i[0]||s[1]>o[1]||n[1]<i[1])}(t.boundingBox(),o.boundingBox()))return;const l=(e+s)/2,c=(a+h)/2;if(0===n.snap0(s-e)&&0===n.snap0(h-a))return void i.add(l,c);const[u,p]=t.split([.5]),[d,g]=o.split([.5]);r(u,e,l,d,a,c),r(p,l,s,d,a,c),r(u,e,l,g,c,h),r(p,l,s,g,c,h)};return r(t,0,1,e,0,1),i.done()}function d(t,e,s){if(t instanceof a){if(e instanceof a)return c(t,e,s);if(e instanceof h)return u(t,e,s,!1)}else if(t instanceof h){if(e instanceof a)return u(e,t,s,!0);if(e instanceof h)return p(t,e,s)}throw new Error("PolyBool: Unknown segment instance in segmentsIntersect")}class g{constructor(t,e=null,s=null){var n,i,o;this.otherFill=null,this.id=null!==(n=null==s?void 0:s.segmentId())&&void 0!==n?n:-1,this.data=t,this.myFill={above:null!==(i=null==e?void 0:e.above)&&void 0!==i?i:null,below:null!==(o=null==e?void 0:e.below)&&void 0!==o?o:null}}}class f extends g{}class m extends g{}function v(t,e){if(t instanceof f)return new f(t.data,t.myFill,e);if(t instanceof m)return new m(t.data,t.myFill,e);throw new Error("PolyBool: Unknown SegmentBool in copySegmentBool")}class w{constructor(t,e,s,n){this.status=null,this.isStart=t,this.p=e,this.seg=s,this.primary=n}}class b{constructor(){this.nodes=[]}remove(t){const e=this.nodes.indexOf(t);e>=0&&this.nodes.splice(e,1)}getIndex(t){return this.nodes.indexOf(t)}isEmpty(){return this.nodes.length<=0}getHead(){return this.nodes[0]}removeHead(){this.nodes.shift()}insertBefore(t,e){this.findTransition(t,e).insert(t)}findTransition(t,e){var s,n;let i=0,o=this.nodes.length;for(;i<o;){const s=i+o>>1;r=this.nodes[s],e(t)-e(r)>0?o=s:i=s+1}var r;return{before:i<=0?null:null!==(s=this.nodes[i-1])&&void 0!==s?s:null,after:null!==(n=this.nodes[i])&&void 0!==n?n:null,insert:t=>(this.nodes.splice(i,0,t),t)}}}class S{constructor(t,e,s=null){this.events=new b,this.status=new b,this.selfIntersection=t,this.geo=e,this.log=s}compareEvents(t,e,s,n,i,o,r,h){const l=this.geo.compareVec2(e,o);return 0!==l?l:n instanceof a&&h instanceof a&&this.geo.isEqualVec2(s,r)?0:t!==i?t?1:-1:this.compareSegments(h,n)}addEvent(t){this.events.insertBefore(t,(e=>e===t?0:this.compareEvents(t.isStart,t.p,t.other.p,t.seg.data,e.isStart,e.p,e.other.p,e.seg.data)))}divideEvent(t,e,s){var n,i;null===(n=this.log)||void 0===n||n.segmentDivide(t.seg,s);const[o,r]=t.seg.data.split([e]);o.setEnd(s),r.setStart(s);const l=r instanceof a?new f(r,t.seg.myFill,this.log):r instanceof h?new m(r,t.seg.myFill,this.log):null;if(!l)throw new Error("PolyBool: Unknown segment data in divideEvent");return this.events.remove(t.other),t.seg.data=o,null===(i=this.log)||void 0===i||i.segmentChop(t.seg),t.other.p=s,this.addEvent(t.other),this.addSegment(l,t.primary)}addSegment(t,e){const s=new w(!0,t.data.start(),t,e),n=new w(!1,t.data.end(),t,e);return s.other=n,n.other=s,this.addEvent(s),this.addEvent(n),s}addLine(t,e,s=!0){const n=this.geo.compareVec2(t,e);0!==n&&this.addSegment(new f(new a(n<0?t:e,n<0?e:t,this.geo),null,this.log),s)}addCurve(t,e,s,n,i=!0){const o=new h(t,e,s,n,this.geo),r=o.split(o.inflectionTValues());for(const t of r){const e=this.geo.compareVec2(t.start(),t.end());if(0===e)continue;const s=t.toLine();s?this.addLine(s.p0,s.p1,i):this.addSegment(new m(e<0?t:t.reverse(),null,this.log),i)}}addRegion(t){let e,s=t[t.length-1];for(let n=0;n<t.length;n++){e=s,s=t[n];const i=this.geo.compareVec2(e,s);0!==i&&this.addSegment(new f(new a(i<0?e:s,i<0?s:e,this.geo),null,this.log),!0)}}compareSegments(t,e){let s=t.start(),n=e.start2();const i=e.start();if(e.pointOn(s)){if(s=t.start2(),t instanceof a&&e instanceof a&&e.pointOn(s))return 0;if(e instanceof h&&0===this.geo.snap0(s[0]-i[0])&&0===this.geo.snap0(n[0]-i[0]))return Math.sign(i[1]-s[1])}else{if(e instanceof h){const t=e.mapXtoY(s[0]);if(!1!==t)return Math.sign(t-s[1])}if(t instanceof h){const s=d(t,e,!0);if(s&&"tValuePairs"===s.kind)for(const e of s.tValuePairs){const s=this.geo.snap01(e[0]);if(s>0&&s<1){n=t.point(s);break}}}}const[o,r]=s,[l,c]=n,[u,p]=i;return Math.sign((l-o)*(p-r)-(c-r)*(u-o))}statusFindSurrounding(t){return this.status.findTransition(t,(e=>{if(t===e)return 0;const s=this.compareSegments(t.seg.data,e.seg.data);return 0===s?-1:s}))}checkIntersection(t,e){var s;const n=t.seg,i=e.seg;null===(s=this.log)||void 0===s||s.checkIntersection(n,i);const o=d(n.data,i.data,!1);if(null===o)return null;if("tRangePairs"===o.kind){const{tStart:[s,r],tEnd:[a,h]}=o;if(1===s&&1===a&&0===r&&0===h||0===s&&0===a&&1===r&&1===h)return null;if(0===s&&1===a&&0===r&&1===h)return e;const l=n.data.start(),c=n.data.end(),u=i.data.end();return 0===s&&0===r?(1===a?this.divideEvent(e,h,c):this.divideEvent(t,a,u),e):(r>0&&r<1&&(1===a&&1===h||(1===a?this.divideEvent(e,h,c):this.divideEvent(t,a,u)),this.divideEvent(e,r,l)),null)}if("tValuePairs"===o.kind){if(o.tValuePairs.length<=0)return null;let s=o.tValuePairs[0];for(let t=1;t<o.tValuePairs.length&&(0===s[0]&&0===s[1]||0===s[0]&&1===s[1]||1===s[0]&&0===s[1]||1===s[0]&&1===s[1]);t++)s=o.tValuePairs[t];const[r,a]=s,h=0===a?i.data.start():1===a?i.data.end():0===r?n.data.start():1===r?n.data.end():n.data.point(r);return r>0&&r<1&&this.divideEvent(t,r,h),a>0&&a<1&&this.divideEvent(e,a,h),null}throw new Error("PolyBool: Unknown intersection type")}calculate(){var t,e,s,n,i,o,r,a;const h=[];for(;!this.events.isEmpty();){const a=this.events.getHead();if(null===(t=this.log)||void 0===t||t.vert(a.p[0]),a.isStart){null===(e=this.log)||void 0===e||e.segmentNew(a.seg,a.primary);const t=this.statusFindSurrounding(a),r=t.before,h=t.after;null===(s=this.log)||void 0===s||s.tempStatus(a.seg,!!r&&r.seg,!!h&&h.seg);const l=()=>{if(r){const t=this.checkIntersection(a,r);if(t)return t}return h?this.checkIntersection(a,h):null},c=l();if(c){if(this.selfIntersection){let t;t=null===a.seg.myFill.below||a.seg.myFill.above!==a.seg.myFill.below,t&&(c.seg.myFill.above=!c.seg.myFill.above)}else c.seg.otherFill=a.seg.myFill;null===(n=this.log)||void 0===n||n.segmentUpdate(c.seg),this.events.remove(a.other),this.events.remove(a)}if(this.events.getHead()!==a){null===(i=this.log)||void 0===i||i.rewind(a.seg);continue}if(this.selfIntersection){let t;t=null===a.seg.myFill.below||a.seg.myFill.above!==a.seg.myFill.below,a.seg.myFill.below=!!h&&h.seg.myFill.above,a.seg.myFill.above=t?!a.seg.myFill.below:a.seg.myFill.below}else if(null===a.seg.otherFill){let t;if(h)if(a.primary===h.primary){if(null===h.seg.otherFill)throw new Error("PolyBool: Unexpected state of otherFill (null)");t=h.seg.otherFill.above}else t=h.seg.myFill.above;else t=!1;a.seg.otherFill={above:t,below:t}}null===(o=this.log)||void 0===o||o.status(a.seg,!!r&&r.seg,!!h&&h.seg),a.other.status=t.insert(a)}else{const t=a.status;if(null===t)throw new Error("PolyBool: Zero-length segment detected; your epsilon is probably too small or too large");const e=this.status.getIndex(t);if(e>0&&e<this.status.nodes.length-1){const t=this.status.nodes[e-1],s=this.status.nodes[e+1];this.checkIntersection(t,s)}if(null===(r=this.log)||void 0===r||r.statusRemove(t.seg),this.status.remove(t),!a.primary){if(!a.seg.otherFill)throw new Error("PolyBool: Unexpected state of otherFill (null)");const t=a.seg.myFill;a.seg.myFill=a.seg.otherFill,a.seg.otherFill=t}h.push(a.seg)}this.events.removeHead()}return null===(a=this.log)||void 0===a||a.done(),h}}function y(t,e,s){const n=[];for(const i of t){const t=(i.myFill.above?8:0)+(i.myFill.below?4:0)+(i.otherFill&&i.otherFill.above?2:0)+(i.otherFill&&i.otherFill.below?1:0);if(0!==e[t]){const o={above:1===e[t],below:2===e[t]};if(i instanceof f)n.push(new f(i.data,o,s));else{if(!(i instanceof m))throw new Error("PolyBool: Unknown SegmentBool type in SegmentSelector");n.push(new m(i.data,o,s))}}}return null==s||s.selected(n),n}class P{static union(t,e){return y(t,[0,2,1,0,2,2,0,0,1,0,1,0,0,0,0,0],e)}static intersect(t,e){return y(t,[0,0,0,0,0,2,0,2,0,0,1,1,0,2,1,0],e)}static difference(t,e){return y(t,[0,0,0,0,2,0,2,0,1,1,0,0,0,1,2,0],e)}static differenceRev(t,e){return y(t,[0,2,1,0,0,0,1,1,0,2,0,2,0,0,0,0],e)}static xor(t,e){return y(t,[0,2,1,0,2,0,0,1,1,0,0,2,0,1,2,0],e)}}function x(t,e,s,n){const i=[],o=[];for(const r of t){let l=r.data;const c=l.start(),u=l.end();if(l instanceof a&&s.isEqualVec2(c,u)){console.warn("PolyBool: Warning: Zero-length segment detected; your epsilon is probably too small or too large");continue}null==n||n.chainStart(l);const p={index:0,matchesHead:!1,matchesPt1:!1},d={index:0,matchesHead:!1,matchesPt1:!1};let g=p;function f(t,e,s){return g&&(g.index=t,g.matchesHead=e,g.matchesPt1=s),g===p?(g=d,!1):(g=null,!0)}for(let m=0;m<i.length;m++){const v=i[m],w=v[0].start(),b=v[v.length-1].end();if(s.isEqualVec2(w,c)){if(f(m,!0,!0))break}else if(s.isEqualVec2(w,u)){if(f(m,!0,!1))break}else if(s.isEqualVec2(b,c)){if(f(m,!1,!0))break}else if(s.isEqualVec2(b,u)&&f(m,!1,!1))break}if(g===p)null==n||n.chainNew(l),i.push([l]);else if(g===d){const S=p.index;null==n||n.chainMatch(S);const y=i[S];if(p.matchesHead?p.matchesPt1?(l=l.reverse(),null==n||n.chainAddHead(S,l),y.unshift(l)):(null==n||n.chainAddHead(S,l),y.unshift(l)):p.matchesPt1?(null==n||n.chainAddTail(S,l),y.push(l)):(l=l.reverse(),null==n||n.chainAddTail(S,l),y.push(l)),l instanceof a)if(p.matchesHead){const E=y[1];E&&E instanceof a&&s.isCollinear(l.p0,E.p0,E.p1)&&(E.setStart(l.p0),null==n||n.chainSimplifyHead(S,E),y.shift())}else{const V=y[y.length-2];V&&V instanceof a&&s.isCollinear(V.p0,V.p1,l.p1)&&(V.setEnd(l.p1),null==n||n.chainSimplifyTail(S,V),y.pop())}const P=y[0],x=y[y.length-1];y.length>0&&s.isEqualVec2(P.start(),x.end())&&(P!==x&&P instanceof a&&x instanceof a&&s.isCollinear(P.p1,P.p0,x.p0)&&(P.setStart(x.p0),null==n||n.chainSimplifyClose(S,P),y.pop()),null==n||n.chainClose(S),i.splice(S,1),o.push(y))}else{function M(t){null==n||n.chainReverse(t);const e=[];for(const s of i[t])e.unshift(s.reverse());i[t]=e}function C(t,e){const o=i[t],r=i[e];if(null==n||n.chainAddTail(t,l),o.push(l),l instanceof a){const e=o[o.length-2];e&&e instanceof a&&s.isCollinear(e.p0,e.p1,l.p1)&&(e.setEnd(l.p1),null==n||n.chainSimplifyTail(t,e),o.pop())}const h=o[o.length-1],c=r[0];h instanceof a&&c instanceof a&&s.isCollinear(h.p0,c.p0,c.p1)&&(h.setEnd(c.p1),null==n||n.chainSimplifyJoin(t,e,h),r.shift()),null==n||n.chainJoin(t,e),i[t]=o.concat(r),i.splice(e,1)}const T=p.index,F=d.index;null==n||n.chainConnect(T,F);const k=i[T].length<i[F].length;p.matchesHead?d.matchesHead?k?(p.matchesPt1||(l=l.reverse()),M(T),C(T,F)):(p.matchesPt1&&(l=l.reverse()),M(F),C(F,T)):(p.matchesPt1&&(l=l.reverse()),C(F,T)):d.matchesHead?(p.matchesPt1||(l=l.reverse()),C(T,F)):k?(p.matchesPt1&&(l=l.reverse()),M(T),C(F,T)):(p.matchesPt1||(l=l.reverse()),M(F),C(T,F))}}for(const I of o){e.beginPath();for(let B=0;B<I.length;B++){const _=I[B];if(0===B){const q=_.start();e.moveTo(q[0],q[1])}if(_ instanceof a)e.lineTo(_.p1[0],_.p1[1]);else{if(!(_ instanceof h))throw new Error("PolyBool: Unknown segment instance");e.bezierCurveTo(_.p1[0],_.p1[1],_.p2[0],_.p2[1],_.p3[0],_.p3[1])}}e.closePath()}}class E{constructor(t,e,s=null){this.pathState={kind:"beginPath"},this.geo=e,this.log=s,this.resultState=t?{final:!0,segments:t}:{final:!1,selfIntersect:new S(!0,this.geo,this.log)}}beginPath(){return this.endPath()}moveTo(t,e){if(this.resultState.final)throw new Error("PolyBool: Cannot change shape after using it in an operation");"beginPath"!==this.pathState.kind&&this.beginPath();const s=[t,e];return this.pathState={kind:"moveTo",start:s,current:s},this}lineTo(t,e){if(this.resultState.final)throw new Error("PolyBool: Cannot change shape after using it in an operation");if("moveTo"!==this.pathState.kind)throw new Error("PolyBool: Must call moveTo prior to calling lineTo");const s=[t,e];return this.resultState.selfIntersect.addLine(this.pathState.current,s),this.pathState.current=s,this}bezierCurveTo(t,e,s,n,i,o){if(this.resultState.final)throw new Error("PolyBool: Cannot change shape after using it in an operation");if("moveTo"!==this.pathState.kind)throw new Error("PolyBool: Must call moveTo prior to calling bezierCurveTo");const r=[i,o];return this.resultState.selfIntersect.addCurve(this.pathState.current,[t,e],[s,n],r),this.pathState.current=r,this}closePath(){if(this.resultState.final)throw new Error("PolyBool: Cannot change shape after using it in an operation");return"moveTo"!==this.pathState.kind||this.geo.isEqualVec2(this.pathState.start,this.pathState.current)||this.lineTo(this.pathState.start[0],this.pathState.start[1]),this.endPath()}endPath(){if(this.resultState.final)throw new Error("PolyBool: Cannot change shape after using it in an operation");return this.pathState={kind:"beginPath"},this}selfIntersect(){return this.resultState.final||(this.resultState={final:!0,segments:this.resultState.selfIntersect.calculate()}),this.resultState.segments}output(t){return x(this.selfIntersect(),t,this.geo,this.log),t}combine(t){const e=new S(!1,this.geo,this.log);for(const t of this.selfIntersect())e.addSegment(v(t,this.log),!0);for(const s of t.selfIntersect())e.addSegment(v(s,this.log),!1);return new V(e.calculate(),this.geo,this.log)}}class V{constructor(t,e,s=null){this.geo=e,this.segments=t,this.log=s}union(){return new E(P.union(this.segments,this.log),this.geo,this.log)}intersect(){return new E(P.intersect(this.segments,this.log),this.geo,this.log)}difference(){return new E(P.difference(this.segments,this.log),this.geo,this.log)}differenceRev(){return new E(P.differenceRev(this.segments,this.log),this.geo,this.log)}xor(){return new E(P.xor(this.segments,this.log),this.geo,this.log)}}class M{constructor(){this.list=[],this.nextSegmentId=0,this.curVert=NaN}push(t,e){this.list.push({type:t,data:JSON.parse(JSON.stringify(e))})}info(t,e){this.push("info",{msg:t,data:e})}segmentId(){return this.nextSegmentId++}checkIntersection(t,e){this.push("check",{seg1:t,seg2:e})}segmentDivide(t,e){this.push("div_seg",{seg:t,p:e})}segmentChop(t){this.push("chop",{seg:t})}statusRemove(t){this.push("pop_seg",{seg:t})}segmentUpdate(t){this.push("seg_update",{seg:t})}segmentNew(t,e){this.push("new_seg",{seg:t,primary:e})}tempStatus(t,e,s){this.push("temp_status",{seg:t,above:e,below:s})}rewind(t){this.push("rewind",{seg:t})}status(t,e,s){this.push("status",{seg:t,above:e,below:s})}vert(t){t!==this.curVert&&(this.push("vert",{x:t}),this.curVert=t)}selected(t){this.push("selected",{segs:t})}chainStart(t){this.push("chain_start",{seg:t})}chainNew(t){this.push("chain_new",{seg:t})}chainMatch(t){this.push("chain_match",{index:t})}chainClose(t){this.push("chain_close",{index:t})}chainAddHead(t,e){this.push("chain_add_head",{index:t,seg:e})}chainAddTail(t,e){this.push("chain_add_tail",{index:t,seg:e})}chainSimplifyHead(t,e){this.push("chain_simp_head",{index:t,seg:e})}chainSimplifyTail(t,e){this.push("chain_simp_tail",{index:t,seg:e})}chainSimplifyClose(t,e){this.push("chain_simp_close",{index:t,seg:e})}chainSimplifyJoin(t,e,s){this.push("chain_simp_join",{index1:t,index2:e,seg:s})}chainConnect(t,e){this.push("chain_con",{index1:t,index2:e})}chainReverse(t){this.push("chain_rev",{index:t})}chainJoin(t,e){this.push("chain_join",{index1:t,index2:e})}done(){this.push("done",null)}}class C{constructor(t=new n,e=null){this.geo=t,this.log=e}shape(){return new E(null,this.geo,this.log)}buildLog(t){var e;return this.log=t?new M:null,null===(e=this.log)||void 0===e?void 0:e.list}segments(t){const e=this.shape();for(const s of t.regions){e.beginPath();const t=s[s.length-1];e.moveTo(t[t.length-2],t[t.length-1]);for(const t of s)if(2===t.length)e.lineTo(t[0],t[1]);else{if(6!==t.length)throw new Error("PolyBool: Invalid point in region");e.bezierCurveTo(t[0],t[1],t[2],t[3],t[4],t[5])}e.closePath()}return{shape:e,inverted:t.inverted}}combine(t,e){return{shape:t.shape.combine(e.shape),inverted1:t.inverted,inverted2:e.inverted}}selectUnion(t){return{shape:t.inverted1?t.inverted2?t.shape.intersect():t.shape.difference():t.inverted2?t.shape.differenceRev():t.shape.union(),inverted:t.inverted1||t.inverted2}}selectIntersect(t){return{shape:t.inverted1?t.inverted2?t.shape.union():t.shape.differenceRev():t.inverted2?t.shape.difference():t.shape.intersect(),inverted:t.inverted1&&t.inverted2}}selectDifference(t){return{shape:t.inverted1?t.inverted2?t.shape.differenceRev():t.shape.union():t.inverted2?t.shape.intersect():t.shape.difference(),inverted:t.inverted1&&!t.inverted2}}selectDifferenceRev(t){return{shape:t.inverted1?t.inverted2?t.shape.difference():t.shape.intersect():t.inverted2?t.shape.union():t.shape.differenceRev(),inverted:!t.inverted1&&t.inverted2}}selectXor(t){return{shape:t.shape.xor(),inverted:t.inverted1!==t.inverted2}}polygon(t){const e=[],s={beginPath:()=>{e.push([])},moveTo:()=>{},lineTo:(t,s)=>{e[e.length-1].push([t,s])},bezierCurveTo:(t,s,n,i,o,r)=>{e[e.length-1].push([t,s,n,i,o,r])},closePath:()=>{}};return t.shape.output(s),{regions:e,inverted:t.inverted}}union(t,e){const s=this.segments(t),n=this.segments(e),i=this.combine(s,n),o=this.selectUnion(i);return this.polygon(o)}intersect(t,e){const s=this.segments(t),n=this.segments(e),i=this.combine(s,n),o=this.selectIntersect(i);return this.polygon(o)}difference(t,e){const s=this.segments(t),n=this.segments(e),i=this.combine(s,n),o=this.selectDifference(i);return this.polygon(o)}differenceRev(t,e){const s=this.segments(t),n=this.segments(e),i=this.combine(s,n),o=this.selectDifferenceRev(i);return this.polygon(o)}xor(t,e){const s=this.segments(t),n=this.segments(e),i=this.combine(s,n),o=this.selectXor(i);return this.polygon(o)}}const T=new C;exports.BuildLog=M,exports.GeometryEpsilon=n,exports.Intersecter=S,exports.PolyBool=C,exports.SegmentBase=r,exports.SegmentChainer=x,exports.SegmentCurve=h,exports.SegmentLine=a,exports.SegmentSelector=P,exports.SegmentTValuePairsBuilder=o,exports.SegmentTValuesBuilder=i,exports.Shape=E,exports.ShapeCombined=V,exports.default=T,exports.projectPointOntoSegmentLine=l,exports.segmentCurveIntersectSegmentCurve=p,exports.segmentLineIntersectSegmentCurve=u,exports.segmentLineIntersectSegmentLine=c,exports.segmentsIntersect=d;
