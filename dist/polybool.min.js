function t(t,e,s){return t+(e-t)*s}function e(e,s,n){return[t(e[0],s[0],n),t(e[1],s[1],n)]}function s(t,e){const[s,n]=t,[i,o]=e;return!(s[0]>o[0]||n[0]<i[0]||s[1]>o[1]||n[1]<i[1])}class n{}class i extends n{constructor(t=1e-10){super(),this.epsilon=t}snap0(t){return Math.abs(t)<this.epsilon?0:t}snap01(t){return Math.abs(t)<this.epsilon?0:Math.abs(1-t)<this.epsilon?1:t}isCollinear(t,e,s){const n=t[0]-e[0],i=t[1]-e[1],o=e[0]-s[0],r=e[1]-s[1];return Math.abs(n*r-o*i)<this.epsilon}solveCubicNormalized(t,e,s){const n=t/3,i=e/3,o=n*n-i,r=n*(n*n-e/2)+s/2;if(Math.abs(r)<this.epsilon&&Math.abs(o)<this.epsilon)return[-n];const h=n*(n*(4*n*s-i*e)-2*e*s)+4*i*i*i+s*s;if(Math.abs(h)<this.epsilon){const e=Math.sqrt(o);return r>0?[-2*e-t/3,e-t/3]:[-e-t/3,2*e-t/3]}const a=o*o*o,l=r*r;if(l<a){const t=(r<0?-1:1)*Math.sqrt(l/a),e=Math.acos(t),s=-2*Math.sqrt(o);return[s*Math.cos(e/3)-n,s*Math.cos((e+2*Math.PI)/3)-n,s*Math.cos((e-2*Math.PI)/3)-n].sort(((t,e)=>t-e))}{const t=(r<0?1:-1)*Math.pow(Math.abs(r)+Math.sqrt(l-a),1/3);return[t+(Math.abs(t)>=this.epsilon?o/t:0)-n]}}solveCubic(t,e,s,n){if(Math.abs(t)<this.epsilon){if(Math.abs(e)<this.epsilon)return Math.abs(s)<this.epsilon?Math.abs(n)<this.epsilon?[0]:[]:[-n/s];const t=2*e;let i=s*s-4*e*n;return Math.abs(i)<this.epsilon?[-s/t]:i>0?(i=Math.sqrt(i),[(-s+i)/t,(-s-i)/t].sort(((t,e)=>t-e))):[]}return this.solveCubicNormalized(e/t,s/t,n/t)}isEqualVec2(t,e){return Math.abs(t[0]-e[0])<this.epsilon&&Math.abs(t[1]-e[1])<this.epsilon}compareVec2(t,e){return Math.abs(e[0]-t[0])<this.epsilon?Math.abs(e[1]-t[1])<this.epsilon?0:t[1]<e[1]?-1:1:t[0]<e[0]?-1:1}}class o{constructor(t){this.tValues=[],this.geo=t}addArray(t){for(const e of t)this.tValues.push(e);return this}add(t){if((t=this.geo.snap01(t))<0||t>1)return this;for(const e of this.tValues)if(0===this.geo.snap0(t-e))return this;return this.tValues.push(t),this}list(){return this.tValues.sort(((t,e)=>t-e)),this.tValues}}class r{constructor(t,e){this.tValuePairs=[],this.allowOutOfRange=t,this.geo=e}add(t,e){if(t=this.geo.snap01(t),e=this.geo.snap01(e),!this.allowOutOfRange&&(t<0||t>1||e<0||e>1))return this;for(const s of this.tValuePairs)if(0===this.geo.snap0(t-s[0])||0===this.geo.snap0(e-s[1]))return this;return this.tValuePairs.push([t,e]),this}list(){return this.tValuePairs.sort(((t,e)=>t[0]-e[0])),this.tValuePairs}done(){return this.tValuePairs.length<=0?null:{kind:"tValuePairs",tValuePairs:this.list()}}}class h{}class a extends h{constructor(t,e,s){super(),this.p0=t,this.p1=e,this.geo=s}copy(){return new a(this.p0,this.p1,this.geo)}isEqual(t){return this.geo.isEqualVec2(this.p0,t.p0)&&this.geo.isEqualVec2(this.p1,t.p1)}start(){return this.p0}start2(){return this.p1}end2(){return this.p0}end(){return this.p1}setStart(t){this.p0=t}setEnd(t){this.p1=t}point(t){const e=this.p0,s=this.p1;return 0===t?e:1===t?s:[e[0]+(s[0]-e[0])*t,e[1]+(s[1]-e[1])*t]}split(t){if(t.length<=0)return[this];const e=t.map((t=>this.point(t)));e.push(this.p1);const s=[];let n=this.p0;for(const t of e)s.push(new a(n,t,this.geo)),n=t;return s}reverse(){return new a(this.p1,this.p0,this.geo)}boundingBox(){const t=this.p0,e=this.p1;return[[Math.min(t[0],e[0]),Math.min(t[1],e[1])],[Math.max(t[0],e[0]),Math.max(t[1],e[1])]]}pointOn(t){return this.geo.isCollinear(t,this.p0,this.p1)}draw(t){const e=this.p0,s=this.p1;return t.moveTo(e[0],e[1]),t.lineTo(s[0],s[1]),t}}class l extends h{constructor(t,e,s,n,i){super(),this.p0=t,this.p1=e,this.p2=s,this.p3=n,this.geo=i}copy(){return new l(this.p0,this.p1,this.p2,this.p3,this.geo)}isEqual(t){return this.geo.isEqualVec2(this.p0,t.p0)&&this.geo.isEqualVec2(this.p1,t.p1)&&this.geo.isEqualVec2(this.p2,t.p2)&&this.geo.isEqualVec2(this.p3,t.p3)}start(){return this.p0}start2(){return this.p1}end2(){return this.p2}end(){return this.p3}setStart(t){this.p0=t}setEnd(t){this.p3=t}point(t){const e=this.p0,s=this.p1,n=this.p2,i=this.p3;if(0===t)return e;if(1===t)return i;const o=(1-t)*(1-t),r=t*t,h=o*(1-t),a=3*o*t,l=3*r*(1-t),c=r*t;return[e[0]*h+s[0]*a+n[0]*l+i[0]*c,e[1]*h+s[1]*a+n[1]*l+i[1]*c]}split(t){if(t.length<=0)return[this];const s=[],n=(t,n)=>{const[i,o,r,h]=t,a=e(i,o,n),c=e(o,r,n),u=e(r,h,n),p=e(a,c,n),d=e(c,u,n),g=e(p,d,n);return s.push(new l(i,a,p,g,this.geo)),[g,d,u,h]};let i=[this.p0,this.p1,this.p2,this.p3],o=0;for(const e of t)i=n(i,(e-o)/(1-o)),o=e;return s.push(new l(i[0],i[1],i[2],i[3],this.geo)),s}reverse(){return new l(this.p3,this.p2,this.p1,this.p0,this.geo)}getCubicCoefficients(t){const e=this.p0[t],s=this.p1[t],n=this.p2[t];return[this.p3[t]-3*n+3*s-e,3*n-6*s+3*e,3*s-3*e,e]}boundingTValues(){const t=new o(this.geo),e=(e,s,n,i)=>{const o=3*i-9*n+9*s-3*e,r=6*e-12*s+6*n,h=3*s-3*e;if(0===this.geo.snap0(o))t.add(-h/r);else{const e=r*r-4*o*h;if(e>=0){const s=Math.sqrt(e);t.add((-r+s)/(2*o)),t.add((-r-s)/(2*o))}}return t},s=this.p0,n=this.p1,i=this.p2,r=this.p3;return e(s[0],n[0],i[0],r[0]),e(s[1],n[1],i[1],r[1]),t.list()}inflectionTValues(){const t=new o(this.geo);t.addArray(this.boundingTValues());const e=this.p0,s=this.p1,n=this.p2,i=this.p3,r=3*(s[0]-e[0]),h=3*(s[1]-e[1]),a=6*(n[0]-s[0]),l=6*(n[1]-s[1]),c=3*(i[0]-n[0]),u=3*(i[1]-n[1]),p=6*(n[0]-2*s[0]+e[0]),d=6*(n[1]-2*s[1]+e[1]),g=r-a+c,f=h-l+u,m=a-2*r,v=l-2*h,w=6*(i[0]-2*n[0]+s[0])-p,b=6*(i[1]-2*n[1]+s[1])-d,P=g*b-f*w,y=g*d+m*b-f*p-v*w,S=m*d+r*b-v*p-h*w,E=r*d-h*p;for(const e of this.geo.solveCubic(P,y,S,E))t.add(e);return t.list()}boundingBox(){const t=this.p0,e=this.p3,s=[Math.min(t[0],e[0]),Math.min(t[1],e[1])],n=[Math.max(t[0],e[0]),Math.max(t[1],e[1])];for(const t of this.boundingTValues()){const e=this.point(t);s[0]=Math.min(s[0],e[0]),s[1]=Math.min(s[1],e[1]),n[0]=Math.max(n[0],e[0]),n[1]=Math.max(n[1],e[1])}return[s,n]}mapXtoT(t,e=!1){if(0===this.geo.snap0(this.p0[0]-t))return 0;if(0===this.geo.snap0(this.p3[0]-t))return 1;const s=this.p0[0]-t,n=this.p1[0]-t,i=this.p2[0]-t,o=[this.p3[0]-t-3*i+3*n-s,3*i-6*n+3*s,3*n-3*s,s];for(const t of this.geo.solveCubic(o[0],o[1],o[2],o[3])){const e=this.geo.snap01(t);if(e>=0&&e<=1)return t}if(e||t>=Math.min(this.p0[0],this.p3[0])&&t<=Math.max(this.p0[0],this.p3[0]))for(let t=0;t<4;t++){let t=-1;for(let e=0;e<4;e++)0!==o[e]&&(t<0||Math.abs(o[e])<Math.abs(o[t]))&&(t=e);if(t<0)return 0;o[t]=0;for(const t of this.geo.solveCubic(o[0],o[1],o[2],o[3])){const e=this.geo.snap01(t);if(e>=0&&e<=1)return t}}return!1}mapXtoY(t,e=!1){const s=this.mapXtoT(t,e);return!1!==s&&this.point(s)[1]}pointOn(t){if(this.geo.isEqualVec2(this.p0,t)||this.geo.isEqualVec2(this.p3,t))return!0;const e=this.mapXtoY(t[0]);return!1!==e&&0===this.geo.snap0(e-t[1])}toLine(){const t=this.p0,e=this.p1,s=this.p2,n=this.p3;return 0===this.geo.snap0(t[0]-e[0])&&0===this.geo.snap0(t[0]-s[0])&&0===this.geo.snap0(t[0]-n[0])||0===this.geo.snap0(t[1]-e[1])&&0===this.geo.snap0(t[1]-s[1])&&0===this.geo.snap0(t[1]-n[1])?new a(t,n,this.geo):null}draw(t){const e=this.p0,s=this.p1,n=this.p2,i=this.p3;return t.moveTo(e[0],e[1]),t.bezierCurveTo(s[0],s[1],n[0],n[1],i[0],i[1]),t}}function c(t,e){const s=e.p1[0]-e.p0[0],n=e.p1[1]-e.p0[1];return((t[0]-e.p0[0])*s+(t[1]-e.p0[1])*n)/(s*s+n*n)}function u(t,e,s){const n=t.geo,i=t.p0,o=t.p1,h=e.p0,a=e.p1,l=o[0]-i[0],u=o[1]-i[1],p=a[0]-h[0],d=a[1]-h[1],g=l*d-u*p;if(0===n.snap0(g)){if(!n.isCollinear(i,o,h))return null;const s=c(e.p0,t),r=c(e.p1,t),a=n.snap01(Math.min(s,r)),l=n.snap01(Math.max(s,r));if(l<0||a>1)return null;const u=c(t.p0,e),p=c(t.p1,e),d=n.snap01(Math.min(u,p)),g=n.snap01(Math.max(u,p));return g<0||d>1?null:{kind:"tRangePairs",tStart:[Math.max(0,a),Math.max(0,d)],tEnd:[Math.min(1,l),Math.min(1,g)]}}const f=i[0]-h[0],m=i[1]-h[1];return new r(s,n).add((p*m-d*f)/g,(l*m-u*f)/g).done()}function p(t,e,s,n){const i=t.geo,o=t.p0,h=t.p1,a=h[1]-o[1],l=o[0]-h[0];if(0===i.snap0(l)){const t=e.mapXtoT(o[0],!1);if(!1===t)return null;const h=(e.point(t)[1]-o[1])/a,l=new r(s,i);return n?l.add(t,h):l.add(h,t),l.done()}const c=a*o[0]+l*o[1],u=e.getCubicCoefficients(0),p=e.getCubicCoefficients(1),d=a*u[0]+l*p[0],g=a*u[1]+l*p[1],f=a*u[2]+l*p[2],m=a*u[3]+l*p[3]-c,v=i.solveCubic(d,g,f,m),w=new r(s,i);if(0===i.snap0(a))for(const t of v){const e=u[0]*t*t*t+u[1]*t*t+u[2]*t+u[3],s=(o[0]-e)/l;n?w.add(t,s):w.add(s,t)}else for(const t of v){const e=(p[0]*t*t*t+p[1]*t*t+p[2]*t+p[3]-o[1])/a;n?w.add(t,e):w.add(e,t)}return w.done()}function d(t,e,n){const i=t.geo;if(i.isEqualVec2(t.p0,e.p0))return i.isEqualVec2(t.p3,e.p3)?i.isEqualVec2(t.p1,e.p1)&&i.isEqualVec2(t.p2,e.p2)?{kind:"tRangePairs",tStart:[0,0],tEnd:[1,1]}:{kind:"tValuePairs",tValuePairs:[[0,0],[1,1]]}:{kind:"tValuePairs",tValuePairs:[[0,0]]};if(i.isEqualVec2(t.p0,e.p3))return{kind:"tValuePairs",tValuePairs:[[0,1]]};if(i.isEqualVec2(t.p3,e.p0))return{kind:"tValuePairs",tValuePairs:[[1,0]]};if(i.isEqualVec2(t.p3,e.p3))return{kind:"tValuePairs",tValuePairs:[[1,1]]};const o=new r(n,i),h=(t,e,n,r,a,l)=>{if(!s(t.boundingBox(),r.boundingBox()))return;const c=(e+n)/2,u=(a+l)/2;if(0===i.snap0(n-e)&&0===i.snap0(l-a))return void o.add(c,u);const[p,d]=t.split([.5]),[g,f]=r.split([.5]);h(p,e,c,g,a,u),h(d,c,n,g,a,u),h(p,e,c,f,u,l),h(d,c,n,f,u,l)};return h(t,0,1,e,0,1),o.done()}function g(t,e,s){if(t instanceof a){if(e instanceof a)return u(t,e,s);if(e instanceof l)return p(t,e,s,!1)}else if(t instanceof l){if(e instanceof a)return p(e,t,s,!0);if(e instanceof l)return d(t,e,s)}throw new Error("PolyBool: Unknown segment instance in segmentsIntersect")}class f{constructor(t,e=null,s=!1,n=null){var i,o,r;this.otherFill=null,this.id=null!==(i=null==n?void 0:n.segmentId())&&void 0!==i?i:-1,this.data=t,this.myFill={above:null!==(o=null==e?void 0:e.above)&&void 0!==o?o:null,below:null!==(r=null==e?void 0:e.below)&&void 0!==r?r:null},this.closed=s}}class m extends f{}class v extends f{}function w(t,e){if(t instanceof m)return new m(t.data,t.myFill,t.closed,e);if(t instanceof v)return new v(t.data,t.myFill,t.closed,e);throw new Error("PolyBool: Unknown SegmentBool in copySegmentBool")}class b{constructor(t,e,s,n){this.status=null,this.isStart=t,this.p=e,this.seg=s,this.primary=n}}class P{constructor(){this.nodes=[]}remove(t){const e=this.nodes.indexOf(t);e>=0&&this.nodes.splice(e,1)}getIndex(t){return this.nodes.indexOf(t)}isEmpty(){return this.nodes.length<=0}getHead(){return this.nodes[0]}removeHead(){this.nodes.shift()}insertBefore(t,e){this.findTransition(t,e).insert(t)}findTransition(t,e){var s,n;let i=0,o=this.nodes.length;for(;i<o;){const s=i+o>>1;r=this.nodes[s],e(t)-e(r)>0?o=s:i=s+1}var r;return{before:i<=0?null:null!==(s=this.nodes[i-1])&&void 0!==s?s:null,after:null!==(n=this.nodes[i])&&void 0!==n?n:null,insert:t=>(this.nodes.splice(i,0,t),t)}}}class y{constructor(t,e,s=null){this.events=new P,this.status=new P,this.currentPath=[],this.selfIntersection=t,this.geo=e,this.log=s}compareEvents(t,e,s,n,i,o,r,h){const l=this.geo.compareVec2(e,o);return 0!==l?l:n instanceof a&&h instanceof a&&this.geo.isEqualVec2(s,r)?0:t!==i?t?1:-1:this.compareSegments(h,n)}addEvent(t){this.events.insertBefore(t,(e=>e===t?0:this.compareEvents(t.isStart,t.p,t.other.p,t.seg.data,e.isStart,e.p,e.other.p,e.seg.data)))}divideEvent(t,e,s){var n,i;null===(n=this.log)||void 0===n||n.segmentDivide(t.seg,s);const[o,r]=t.seg.data.split([e]);o.setEnd(s),r.setStart(s);const h=r instanceof a?new m(r,t.seg.myFill,t.seg.closed,this.log):r instanceof l?new v(r,t.seg.myFill,t.seg.closed,this.log):null;if(!h)throw new Error("PolyBool: Unknown segment data in divideEvent");return this.events.remove(t.other),t.seg.data=o,null===(i=this.log)||void 0===i||i.segmentChop(t.seg),t.other.p=s,this.addEvent(t.other),this.addSegment(h,t.primary)}beginPath(){this.currentPath=[]}closePath(){for(const t of this.currentPath)t.closed=!0}addSegment(t,e){const s=new b(!0,t.data.start(),t,e),n=new b(!1,t.data.end(),t,e);return s.other=n,n.other=s,this.addEvent(s),this.addEvent(n),s}addLine(t,e,s=!0){const n=this.geo.compareVec2(t,e);if(0===n)return;const i=new m(new a(n<0?t:e,n<0?e:t,this.geo),null,!1,this.log);this.currentPath.push(i),this.addSegment(i,s)}addCurve(t,e,s,n,i=!0){const o=new l(t,e,s,n,this.geo),r=o.split(o.inflectionTValues());for(const t of r){const e=this.geo.compareVec2(t.start(),t.end());if(0===e)continue;const s=t.toLine();if(s)this.addLine(s.p0,s.p1,i);else{const s=new v(e<0?t:t.reverse(),null,!1,this.log);this.currentPath.push(s),this.addSegment(s,i)}}}compareSegments(t,e){let s=t.start(),n=e.start2();const i=e.start();if(e.pointOn(s)){if(s=t.start2(),t instanceof a&&e instanceof a&&e.pointOn(s))return 0;if(e instanceof l&&0===this.geo.snap0(s[0]-i[0])&&0===this.geo.snap0(n[0]-i[0]))return Math.sign(i[1]-s[1])}else{if(e instanceof l){const t=e.mapXtoY(s[0],!0);if(!1!==t)return Math.sign(t-s[1])}if(t instanceof l){const s=g(t,e,!0);if(s&&"tValuePairs"===s.kind)for(const e of s.tValuePairs){const s=this.geo.snap01(e[0]);if(s>0&&s<1){n=t.point(s);break}}}}const[o,r]=s,[h,c]=n,[u,p]=i;return Math.sign((h-o)*(p-r)-(c-r)*(u-o))}statusFindSurrounding(t){return this.status.findTransition(t,(e=>{if(t===e)return 0;const s=this.compareSegments(t.seg.data,e.seg.data);return 0===s?-1:s}))}checkIntersection(t,e){var s;const n=t.seg,i=e.seg;null===(s=this.log)||void 0===s||s.checkIntersection(n,i);const o=g(n.data,i.data,!1);if(null===o)return null;if("tRangePairs"===o.kind){const{tStart:[s,r],tEnd:[h,a]}=o;if(1===s&&1===h&&0===r&&0===a||0===s&&0===h&&1===r&&1===a)return null;if(0===s&&1===h&&0===r&&1===a)return e;const l=n.data.start(),c=n.data.end(),u=i.data.end();return 0===s&&0===r?(1===h?this.divideEvent(e,a,c):this.divideEvent(t,h,u),e):(r>0&&r<1&&(1===h&&1===a||(1===h?this.divideEvent(e,a,c):this.divideEvent(t,h,u)),this.divideEvent(e,r,l)),null)}if("tValuePairs"===o.kind){if(o.tValuePairs.length<=0)return null;let s=o.tValuePairs[0];for(let t=1;t<o.tValuePairs.length&&(0===s[0]&&0===s[1]||0===s[0]&&1===s[1]||1===s[0]&&0===s[1]||1===s[0]&&1===s[1]);t++)s=o.tValuePairs[t];const[r,h]=s,a=0===h?i.data.start():1===h?i.data.end():0===r?n.data.start():1===r?n.data.end():n.data.point(r);return r>0&&r<1&&this.divideEvent(t,r,a),h>0&&h<1&&this.divideEvent(e,h,a),null}throw new Error("PolyBool: Unknown intersection type")}calculate(){var t,e,s,n,i,o,r,h;const a=[];for(;!this.events.isEmpty();){const h=this.events.getHead();if(null===(t=this.log)||void 0===t||t.vert(h.p[0]),h.isStart){null===(e=this.log)||void 0===e||e.segmentNew(h.seg,h.primary);const t=this.statusFindSurrounding(h),r=t.before,a=t.after;null===(s=this.log)||void 0===s||s.tempStatus(h.seg,!!r&&r.seg,!!a&&a.seg);const l=()=>{if(r){const t=this.checkIntersection(h,r);if(t)return t}return a?this.checkIntersection(h,a):null},c=l();if(c){if(this.selfIntersection){let t;t=null===h.seg.myFill.below?h.seg.closed:h.seg.myFill.above!==h.seg.myFill.below,t&&(c.seg.myFill.above=!c.seg.myFill.above)}else c.seg.otherFill=h.seg.myFill;null===(n=this.log)||void 0===n||n.segmentUpdate(c.seg),this.events.remove(h.other),this.events.remove(h)}if(this.events.getHead()!==h){null===(i=this.log)||void 0===i||i.rewind(h.seg);continue}if(this.selfIntersection){let t;t=null===h.seg.myFill.below?h.seg.closed:h.seg.myFill.above!==h.seg.myFill.below,h.seg.myFill.below=!!a&&a.seg.myFill.above,h.seg.myFill.above=t?!h.seg.myFill.below:h.seg.myFill.below}else if(null===h.seg.otherFill){let t;if(a)if(h.primary===a.primary){if(null===a.seg.otherFill)throw new Error("PolyBool: Unexpected state of otherFill (null)");t=a.seg.otherFill.above}else t=a.seg.myFill.above;else t=!1;h.seg.otherFill={above:t,below:t}}null===(o=this.log)||void 0===o||o.status(h.seg,!!r&&r.seg,!!a&&a.seg),h.other.status=t.insert(h)}else{const t=h.status;if(null===t)throw new Error("PolyBool: Zero-length segment detected; your epsilon is probably too small or too large");const e=this.status.getIndex(t);if(e>0&&e<this.status.nodes.length-1){const t=this.status.nodes[e-1],s=this.status.nodes[e+1];this.checkIntersection(t,s)}if(null===(r=this.log)||void 0===r||r.statusRemove(t.seg),this.status.remove(t),!h.primary){if(!h.seg.otherFill)throw new Error("PolyBool: Unexpected state of otherFill (null)");const t=h.seg.myFill;h.seg.myFill=h.seg.otherFill,h.seg.otherFill=t}a.push(h.seg)}this.events.removeHead()}return null===(h=this.log)||void 0===h||h.done(),a}}function S(t,e,s){const n=[];for(const i of t){const t=e[(i.myFill.above?8:0)+(i.myFill.below?4:0)+(i.otherFill&&i.otherFill.above?2:0)+(i.otherFill&&i.otherFill.below?1:0)],o=!!(1&t),r=!!(2&t);if(!i.closed&&0!==t||i.closed&&o!==r){const t={above:o,below:r};if(i instanceof m)n.push(new m(i.data,t,i.closed,s));else{if(!(i instanceof v))throw new Error("PolyBool: Unknown SegmentBool type in SegmentSelector");n.push(new v(i.data,t,i.closed,s))}}}return null==s||s.selected(n),n}class E{static union(t,e){return S(t,[4,2,1,0,2,2,0,0,1,0,1,0,0,0,0,0],e)}static intersect(t,e){return S(t,[0,0,0,4,0,2,0,2,0,0,1,1,4,2,1,0],e)}static difference(t,e){return S(t,[4,0,0,0,2,0,2,0,1,1,0,0,0,1,2,0],e)}static differenceRev(t,e){return S(t,[4,2,1,0,0,0,1,1,0,2,0,2,0,0,0,0],e)}static xor(t,e){return S(t,[4,2,1,0,2,0,0,1,1,0,0,2,0,1,2,0],e)}}function V(t,e,s){return!!s.isCollinear(t.p0,t.p1,e.p1)&&new a(t.p0,e.p1,s)}function M(t,e,s){if(s.isCollinear(t.p2,t.p3,e.p1)){const n=e.p1[0]-t.p2[0],i=e.p1[1]-t.p2[1],o=Math.abs(n)>Math.abs(i)?(t.p3[0]-t.p2[0])/n:(t.p3[1]-t.p2[1])/i,r=s.snap01(o);if(0!==r&&1!==r){const n=new l(t.p0,[t.p0[0]+(t.p1[0]-t.p0[0])/o,t.p0[1]+(t.p1[1]-t.p0[1])/o],[e.p2[0]-o*(e.p3[0]-e.p2[0])/(1-o),e.p2[1]-o*(e.p3[1]-e.p2[1])/(1-o)],e.p3,s),[i,r]=n.split([o]);if(i.isEqual(t)&&r.isEqual(e))return n}}return!1}function x(t,e,s){return t!==e&&(t instanceof a&&e instanceof a?V(t,e,s):t instanceof l&&e instanceof l&&M(t,e,s))}function T(t,e,s){const n=[],i=[],o=[];for(const r of t){let h=r.data;const l=r.closed,c=l?n:i,u=h.start(),p=h.end();if(h instanceof a&&e.isEqualVec2(u,p)){console.warn("PolyBool: Warning: Zero-length segment detected; your epsilon is probably too small or too large");continue}null==s||s.chainStart(h,l);const d={index:0,matchesHead:!1,matchesPt1:!1},g={index:0,matchesHead:!1,matchesPt1:!1};let f=d;function m(t,e,s){return f&&(f.index=t,f.matchesHead=e,f.matchesPt1=s),f===d?(f=g,!1):(f=null,!0)}for(let v=0;v<c.length;v++){const w=c[v],b=w[0].start(),P=w[w.length-1].end();if(e.isEqualVec2(b,u)){if(m(v,!0,!0))break}else if(e.isEqualVec2(b,p)){if(m(v,!0,!1))break}else if(e.isEqualVec2(P,u)){if(m(v,!1,!0))break}else if(e.isEqualVec2(P,p)&&m(v,!1,!1))break}if(f===d)null==s||s.chainNew(h,l),c.push([h]);else if(f===g){const y=d.index;null==s||s.chainMatch(y,l);const S=c[y];if(d.matchesHead?d.matchesPt1?(h=h.reverse(),null==s||s.chainAddHead(y,h,l),S.unshift(h)):(null==s||s.chainAddHead(y,h,l),S.unshift(h)):d.matchesPt1?(null==s||s.chainAddTail(y,h,l),S.push(h)):(h=h.reverse(),null==s||s.chainAddTail(y,h,l),S.push(h)),d.matchesHead){const E=S[1],V=x(h,E,e);V&&(null==s||s.chainSimplifyHead(y,V,l),S.shift(),S[0]=V)}else{const M=x(S[S.length-2],h,e);M&&(null==s||s.chainSimplifyTail(y,M,l),S.pop(),S[S.length-1]=M)}if(l){const T=S[0],F=S[S.length-1];if(S.length>0&&e.isEqualVec2(T.start(),F.end())){const C=x(F,T,e);C&&(null==s||s.chainSimplifyClose(y,C,l),S.pop(),S[0]=C),null==s||s.chainClose(y,l),c.splice(y,1),o.push(S)}}}else{function k(t){null==s||s.chainReverse(t,l);const e=[];for(const s of c[t])e.unshift(s.reverse());c[t]=e}function q(t,n){const i=c[t],o=c[n];null==s||s.chainAddTail(t,h,l),i.push(h);const r=x(i[i.length-2],h,e);r&&(null==s||s.chainSimplifyTail(t,r,l),i.pop(),i[i.length-1]=r);const a=x(i[i.length-1],o[0],e);a&&(null==s||s.chainSimplifyJoin(t,n,a,l),o.shift(),i[i.length-1]=a),null==s||s.chainJoin(t,n,l),c[t]=i.concat(o),c.splice(n,1)}const I=d.index,B=g.index;null==s||s.chainConnect(I,B,l);const _=c[I].length<c[B].length;d.matchesHead?g.matchesHead?_?(d.matchesPt1||(h=h.reverse()),k(I),q(I,B)):(d.matchesPt1&&(h=h.reverse()),k(B),q(B,I)):(d.matchesPt1&&(h=h.reverse()),q(B,I)):g.matchesHead?(d.matchesPt1||(h=h.reverse()),q(I,B)):_?(d.matchesPt1&&(h=h.reverse()),k(I),q(B,I)):(d.matchesPt1||(h=h.reverse()),k(B),q(I,B))}}for(const R of i)o.push(R);return o}function F(t,e,s){for(const n of t){if(n.length<=0)continue;s.beginPath();for(let t=0;t<n.length;t++){const e=n[t];if(0===t){const t=e.start();s.moveTo(t[0],t[1])}if(e instanceof a)s.lineTo(e.p1[0],e.p1[1]);else{if(!(e instanceof l))throw new Error("PolyBool: Unknown segment instance");s.bezierCurveTo(e.p1[0],e.p1[1],e.p2[0],e.p2[1],e.p3[0],e.p3[1])}}const t=n[0],i=n[n.length-1];e.isEqualVec2(t.start(),i.end())&&s.closePath()}return s}class C{constructor(t,e=null,s=null){this.pathState={kind:"beginPath"},this.geo=t,this.log=s,this.resultState=e?{state:"seg",segments:e}:{state:"new",selfIntersect:new y(!0,this.geo,this.log)}}beginPath(){if("new"!==this.resultState.state)throw new Error("PolyBool: Cannot change shape after using it in an operation");return this.resultState.selfIntersect.beginPath(),this.endPath()}moveTo(t,e){if("new"!==this.resultState.state)throw new Error("PolyBool: Cannot change shape after using it in an operation");"beginPath"!==this.pathState.kind&&this.beginPath();const s=[t,e];return this.pathState={kind:"moveTo",start:s,current:s},this}lineTo(t,e){if("new"!==this.resultState.state)throw new Error("PolyBool: Cannot change shape after using it in an operation");if("moveTo"!==this.pathState.kind)throw new Error("PolyBool: Must call moveTo prior to calling lineTo");const s=[t,e];return this.resultState.selfIntersect.addLine(this.pathState.current,s),this.pathState.current=s,this}bezierCurveTo(t,e,s,n,i,o){if("new"!==this.resultState.state)throw new Error("PolyBool: Cannot change shape after using it in an operation");if("moveTo"!==this.pathState.kind)throw new Error("PolyBool: Must call moveTo prior to calling bezierCurveTo");const r=[i,o];return this.resultState.selfIntersect.addCurve(this.pathState.current,[t,e],[s,n],r),this.pathState.current=r,this}closePath(){if("new"!==this.resultState.state)throw new Error("PolyBool: Cannot change shape after using it in an operation");return"moveTo"!==this.pathState.kind||this.geo.isEqualVec2(this.pathState.start,this.pathState.current)||this.lineTo(this.pathState.start[0],this.pathState.start[1]),this.resultState.selfIntersect.closePath(),this.endPath()}endPath(){if("new"!==this.resultState.state)throw new Error("PolyBool: Cannot change shape after using it in an operation");return this.pathState={kind:"beginPath"},this}selfIntersect(){return"new"===this.resultState.state&&(this.resultState={state:"seg",segments:this.resultState.selfIntersect.calculate()}),this.resultState.segments}segments(){if("reg"!==this.resultState.state){const t=this.selfIntersect();this.resultState={state:"reg",segments:t,regions:T(t,this.geo,this.log)}}return this.resultState.regions}output(t){return F(this.segments(),this.geo,t)}combine(t){const e=new y(!1,this.geo,this.log);for(const t of this.selfIntersect())e.addSegment(w(t,this.log),!0);for(const s of t.selfIntersect())e.addSegment(w(s,this.log),!1);return new k(e.calculate(),this.geo,this.log)}}class k{constructor(t,e,s=null){this.geo=e,this.segments=t,this.log=s}union(){return new C(this.geo,E.union(this.segments,this.log),this.log)}intersect(){return new C(this.geo,E.intersect(this.segments,this.log),this.log)}difference(){return new C(this.geo,E.difference(this.segments,this.log),this.log)}differenceRev(){return new C(this.geo,E.differenceRev(this.segments,this.log),this.log)}xor(){return new C(this.geo,E.xor(this.segments,this.log),this.log)}}class q{constructor(){this.list=[],this.nextSegmentId=0,this.curVert=NaN}push(t,e){this.list.push({type:t,data:JSON.parse(JSON.stringify(e))})}info(t,e){this.push("info",{msg:t,data:e})}segmentId(){return this.nextSegmentId++}checkIntersection(t,e){this.push("check",{seg1:t,seg2:e})}segmentDivide(t,e){this.push("div_seg",{seg:t,p:e})}segmentChop(t){this.push("chop",{seg:t})}statusRemove(t){this.push("pop_seg",{seg:t})}segmentUpdate(t){this.push("seg_update",{seg:t})}segmentNew(t,e){this.push("new_seg",{seg:t,primary:e})}tempStatus(t,e,s){this.push("temp_status",{seg:t,above:e,below:s})}rewind(t){this.push("rewind",{seg:t})}status(t,e,s){this.push("status",{seg:t,above:e,below:s})}vert(t){t!==this.curVert&&(this.push("vert",{x:t}),this.curVert=t)}selected(t){this.push("selected",{segs:t})}chainStart(t,e){this.push("chain_start",{seg:t,closed:e})}chainNew(t,e){this.push("chain_new",{seg:t,closed:e})}chainMatch(t,e){this.push("chain_match",{index:t,closed:e})}chainClose(t,e){this.push("chain_close",{index:t,closed:e})}chainAddHead(t,e,s){this.push("chain_add_head",{index:t,seg:e,closed:s})}chainAddTail(t,e,s){this.push("chain_add_tail",{index:t,seg:e,closed:s})}chainSimplifyHead(t,e,s){this.push("chain_simp_head",{index:t,seg:e,closed:s})}chainSimplifyTail(t,e,s){this.push("chain_simp_tail",{index:t,seg:e,closed:s})}chainSimplifyClose(t,e,s){this.push("chain_simp_close",{index:t,seg:e,closed:s})}chainSimplifyJoin(t,e,s,n){this.push("chain_simp_join",{index1:t,index2:e,seg:s,closed:n})}chainConnect(t,e,s){this.push("chain_con",{index1:t,index2:e,closed:s})}chainReverse(t,e){this.push("chain_rev",{index:t,closed:e})}chainJoin(t,e,s){this.push("chain_join",{index1:t,index2:e,closed:s})}done(){this.push("done",null)}}class I{constructor(t=new i,e=null){this.geo=t,this.log=e}shape(){return new C(this.geo,null,this.log)}buildLog(t){var e;return this.log=t?new q:null,null===(e=this.log)||void 0===e?void 0:e.list}segments(t){const e=this.shape();for(const s of t.regions){e.beginPath();const t=s[s.length-1];e.moveTo(t[t.length-2],t[t.length-1]);for(const t of s)if(2===t.length)e.lineTo(t[0],t[1]);else{if(6!==t.length)throw new Error("PolyBool: Invalid point in region");e.bezierCurveTo(t[0],t[1],t[2],t[3],t[4],t[5])}e.closePath()}return{shape:e,inverted:t.inverted}}combine(t,e){return{shape:t.shape.combine(e.shape),inverted1:t.inverted,inverted2:e.inverted}}selectUnion(t){return{shape:t.inverted1?t.inverted2?t.shape.intersect():t.shape.difference():t.inverted2?t.shape.differenceRev():t.shape.union(),inverted:t.inverted1||t.inverted2}}selectIntersect(t){return{shape:t.inverted1?t.inverted2?t.shape.union():t.shape.differenceRev():t.inverted2?t.shape.difference():t.shape.intersect(),inverted:t.inverted1&&t.inverted2}}selectDifference(t){return{shape:t.inverted1?t.inverted2?t.shape.differenceRev():t.shape.union():t.inverted2?t.shape.intersect():t.shape.difference(),inverted:t.inverted1&&!t.inverted2}}selectDifferenceRev(t){return{shape:t.inverted1?t.inverted2?t.shape.difference():t.shape.intersect():t.inverted2?t.shape.union():t.shape.differenceRev(),inverted:!t.inverted1&&t.inverted2}}selectXor(t){return{shape:t.shape.xor(),inverted:t.inverted1!==t.inverted2}}polygon(t){const e=[],s={beginPath:()=>{e.push([])},moveTo:()=>{},lineTo:(t,s)=>{e[e.length-1].push([t,s])},bezierCurveTo:(t,s,n,i,o,r)=>{e[e.length-1].push([t,s,n,i,o,r])},closePath:()=>{}};return t.shape.output(s),{regions:e,inverted:t.inverted}}union(t,e){const s=this.segments(t),n=this.segments(e),i=this.combine(s,n),o=this.selectUnion(i);return this.polygon(o)}intersect(t,e){const s=this.segments(t),n=this.segments(e),i=this.combine(s,n),o=this.selectIntersect(i);return this.polygon(o)}difference(t,e){const s=this.segments(t),n=this.segments(e),i=this.combine(s,n),o=this.selectDifference(i);return this.polygon(o)}differenceRev(t,e){const s=this.segments(t),n=this.segments(e),i=this.combine(s,n),o=this.selectDifferenceRev(i);return this.polygon(o)}xor(t,e){const s=this.segments(t),n=this.segments(e),i=this.combine(s,n),o=this.selectXor(i);return this.polygon(o)}}const B=new I;export{b as EventBool,n as Geometry,i as GeometryEpsilon,y as Intersecter,P as ListBool,I as PolyBool,h as SegmentBase,f as SegmentBoolBase,v as SegmentBoolCurve,m as SegmentBoolLine,T as SegmentChainer,l as SegmentCurve,a as SegmentLine,E as SegmentSelector,r as SegmentTValuePairsBuilder,o as SegmentTValuesBuilder,C as Shape,k as ShapeCombined,s as boundingBoxesIntersect,w as copySegmentBool,B as default,M as joinCurves,V as joinLines,x as joinSegments,t as lerp,e as lerpVec2,c as projectPointOntoSegmentLine,d as segmentCurveIntersectSegmentCurve,p as segmentLineIntersectSegmentCurve,u as segmentLineIntersectSegmentLine,g as segmentsIntersect,F as segmentsToReceiver};
