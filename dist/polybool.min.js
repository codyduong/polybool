function t(t,e,s){return t+(e-t)*s}function e(e,s,n){return[t(e[0],s[0],n),t(e[1],s[1],n)]}class s{}class n extends s{constructor(t=1e-10){super(),this.epsilon=t}snap0(t){return Math.abs(t)<this.epsilon?0:t}snap01(t){return Math.abs(t)<this.epsilon?0:Math.abs(1-t)<this.epsilon?1:t}atan2deg(t,e){return Math.abs(t)<this.epsilon?e>0||Math.abs(e)<this.epsilon?0:180:Math.abs(e)<this.epsilon?t<0?270:90:Math.abs(e-t)<this.epsilon?e<0?225:45:Math.abs(e+t)<this.epsilon?e<0?315:135:(180*Math.atan2(t,e)/Math.PI+360)%360}isCollinear(t,e,s){const n=t[0]-e[0],i=t[1]-e[1],o=e[0]-s[0],r=e[1]-s[1];return Math.abs(n*r-o*i)<this.epsilon}solveCubicNormalized(t,e,s){const n=t/3,i=e/3,o=n*n-i,r=n*(n*n-e/2)+s/2;if(Math.abs(r)<this.epsilon&&Math.abs(o)<this.epsilon)return[-n];const h=n*(n*(4*n*s-i*e)-2*e*s)+4*i*i*i+s*s;if(Math.abs(h)<this.epsilon){const t=Math.sqrt(o);return[-2*t-n,t-n].sort(((t,e)=>t-e))}const a=o*o*o,l=r*r;if(l<a){const t=(r<0?-1:1)*Math.sqrt(l/a),e=Math.acos(t),s=-2*Math.sqrt(o);return[s*Math.cos(e/3)-n,s*Math.cos((e+2*Math.PI)/3)-n,s*Math.cos((e-2*Math.PI)/3)-n].sort(((t,e)=>t-e))}{const t=(r<0?1:-1)*Math.pow(Math.abs(r)+Math.sqrt(l-a),1/3);return[t+(Math.abs(t)>=this.epsilon?o/t:0)-n]}}solveCubic(t,e,s,n){if(Math.abs(t)<this.epsilon){if(Math.abs(e)<this.epsilon)return Math.abs(s)<this.epsilon?Math.abs(n)<this.epsilon?[0]:[]:[-n/s];const t=2*e;let i=s*s-4*e*n;return Math.abs(i)<this.epsilon?[-s/t]:i>0?(i=Math.sqrt(i),[(-s+i)/t,(-s-i)/t].sort(((t,e)=>t-e))):[]}return this.solveCubicNormalized(e/t,s/t,n/t)}isEqualVec2(t,e){return Math.abs(t[0]-e[0])<this.epsilon&&Math.abs(t[1]-e[1])<this.epsilon}compareVec2(t,e){return Math.abs(e[0]-t[0])<this.epsilon?Math.abs(e[1]-t[1])<this.epsilon?0:t[1]<e[1]?-1:1:t[0]<e[0]?-1:1}}class i{constructor(t){this.tValues=[],this.geo=t}addArray(t){for(const e of t)this.tValues.push(e);return this}add(t){if((t=this.geo.snap01(t))<0||t>1)return this;for(const e of this.tValues)if(0===this.geo.snap0(t-e))return this;return this.tValues.push(t),this}list(){return this.tValues.sort(((t,e)=>t-e)),this.tValues}}class o{constructor(t,e){this.tValuePairs=[],this.allowOutOfRange=t,this.geo=e}add(t,e){if(t=this.geo.snap01(t),e=this.geo.snap01(e),!this.allowOutOfRange&&(t<0||t>1||e<0||e>1))return this;for(const s of this.tValuePairs)if(0===this.geo.snap0(t-s[0])||0===this.geo.snap0(e-s[1]))return this;return this.tValuePairs.push([t,e]),this}list(){return this.tValuePairs.sort(((t,e)=>t[0]-e[0])),this.tValuePairs}done(){return this.tValuePairs.length<=0?null:{kind:"tValuePairs",tValuePairs:this.list()}}}class r{}class h extends r{constructor(t,e,s){super(),this.p0=t,this.p1=e,this.geo=s}copy(){return new h(this.p0,this.p1,this.geo)}start(){return this.p0}start2(){return this.p1}end(){return this.p1}setStart(t){this.p0=t}setEnd(t){this.p1=t}point(t){const e=this.p0,s=this.p1;return 0===t?e:1===t?s:[e[0]+(s[0]-e[0])*t,e[1]+(s[1]-e[1])*t]}tangentStart(){const t=this.p0,e=this.p1;return this.geo.atan2deg(e[1]-t[1],e[0]-t[0])}tangentEnd(){const t=this.p0,e=this.p1;return this.geo.atan2deg(e[1]-t[1],e[0]-t[0])}split(t){if(t.length<=0)return[this];const e=t.map((t=>this.point(t)));e.push(this.p1);const s=[];let n=this.p0;for(const t of e)s.push(new h(n,t,this.geo)),n=t;return s}reverse(){return new h(this.p1,this.p0,this.geo)}boundingBox(){const t=this.p0,e=this.p1;return[[Math.min(t[0],e[0]),Math.min(t[1],e[1])],[Math.max(t[0],e[0]),Math.max(t[1],e[1])]]}pointOn(t){return this.geo.isCollinear(t,this.p0,this.p1)}draw(t){const e=this.p0,s=this.p1;t.moveTo(e[0],e[1]),t.lineTo(s[0],s[1])}}class a extends r{constructor(t,e,s,n,i){super(),this.p0=t,this.p1=e,this.p2=s,this.p3=n,this.geo=i}copy(){return new a(this.p0,this.p1,this.p2,this.p3,this.geo)}start(){return this.p0}start2(){return this.p1}end(){return this.p3}setStart(t){this.p0=t}setEnd(t){this.p3=t}point(t){const e=this.p0,s=this.p1,n=this.p2,i=this.p3;if(0===t)return e;if(1===t)return i;const o=(1-t)*(1-t),r=t*t,h=o*(1-t),a=3*o*t,l=3*r*(1-t),c=r*t;return[e[0]*h+s[0]*a+n[0]*l+i[0]*c,e[1]*h+s[1]*a+n[1]*l+i[1]*c]}tangentStart(){const t=this.p0,e=this.p1;return this.geo.atan2deg(e[1]-t[1],e[0]-t[0])}tangentEnd(){const t=this.p2,e=this.p3;return this.geo.atan2deg(e[1]-t[1],e[0]-t[0])}split(t){if(t.length<=0)return[this];const s=[],n=(t,n)=>{const[i,o,r,h]=t,l=e(i,o,n),c=e(o,r,n),u=e(r,h,n),p=e(l,c,n),d=e(c,u,n),g=e(p,d,n);return s.push(new a(i,l,p,g,this.geo)),[g,d,u,h]};let i=[this.p0,this.p1,this.p2,this.p3],o=0;for(const e of t)i=n(i,(e-o)/(1-o)),o=e;return s.push(new a(i[0],i[1],i[2],i[3],this.geo)),s}reverse(){return new a(this.p3,this.p2,this.p1,this.p0,this.geo)}getCubicCoefficients(t){const e=this.p0[t],s=this.p1[t],n=this.p2[t];return[this.p3[t]-3*n+3*s-e,3*n-6*s+3*e,3*s-3*e,e]}boundingTValues(){const t=new i(this.geo),e=(e,s,n,i)=>{const o=3*i-9*n+9*s-3*e,r=6*e-12*s+6*n,h=3*s-3*e;if(0===this.geo.snap0(o))t.add(-h/r);else{const e=r*r-4*o*h;if(e>=0){const s=Math.sqrt(e);t.add((-r+s)/(2*o)),t.add((-r-s)/(2*o))}}return t},s=this.p0,n=this.p1,o=this.p2,r=this.p3;return e(s[0],n[0],o[0],r[0]),e(s[1],n[1],o[1],r[1]),t.list()}inflectionTValues(){const t=new i(this.geo);t.addArray(this.boundingTValues());const e=this.p0,s=this.p1,n=this.p2,o=this.p3,r=3*(s[0]-e[0]),h=3*(s[1]-e[1]),a=6*(n[0]-s[0]),l=6*(n[1]-s[1]),c=3*(o[0]-n[0]),u=3*(o[1]-n[1]),p=6*(n[0]-2*s[0]+e[0]),d=6*(n[1]-2*s[1]+e[1]),g=r-a+c,f=h-l+u,m=a-2*r,v=l-2*h,w=6*(o[0]-2*n[0]+s[0])-p,b=6*(o[1]-2*n[1]+s[1])-d,y=g*b-f*w,P=g*d+m*b-f*p-v*w,S=m*d+r*b-v*p-h*w,M=r*d-h*p;for(const e of this.geo.solveCubic(y,P,S,M))t.add(e);return t.list()}boundingBox(){const t=this.p0,e=this.p3,s=[Math.min(t[0],e[0]),Math.min(t[1],e[1])],n=[Math.max(t[0],e[0]),Math.max(t[1],e[1])];for(const t of this.boundingTValues()){const e=this.point(t);s[0]=Math.min(s[0],e[0]),s[1]=Math.min(s[1],e[1]),n[0]=Math.max(n[0],e[0]),n[1]=Math.max(n[1],e[1])}return[s,n]}mapXtoY(t,e=!1){if(0===this.geo.snap0(this.p0[0]-t))return this.p0[1];if(0===this.geo.snap0(this.p3[0]-t))return this.p3[1];const s=this.p0[0]-t,n=this.p1[0]-t,i=this.p2[0]-t,o=this.p3[0]-t-3*i+3*n-s,r=3*i-6*n+3*s,h=3*n-3*s,a=s;for(const t of this.geo.solveCubic(o,r,h,a)){const e=this.geo.snap01(t);if(e>=0&&e<=1)return this.point(t)[1]}if(e)for(const t of[...this.geo.solveCubic(0,r,h,a),...this.geo.solveCubic(0,0,h,a),0]){const e=this.geo.snap01(t);if(e>=0&&e<=1)return this.point(t)[1]}return!1}pointOn(t){if(this.geo.isEqualVec2(this.p0,t)||this.geo.isEqualVec2(this.p3,t))return!0;const e=this.mapXtoY(t[0]);return!1!==e&&0===this.geo.snap0(e-t[1])}toLine(){const t=this.p0,e=this.p1,s=this.p2,n=this.p3;return 0===this.geo.snap0(t[0]-e[0])&&0===this.geo.snap0(t[0]-s[0])&&0===this.geo.snap0(t[0]-n[0])||0===this.geo.snap0(t[1]-e[1])&&0===this.geo.snap0(t[1]-s[1])&&0===this.geo.snap0(t[1]-n[1])?new h(t,n,this.geo):null}draw(t){const e=this.p0,s=this.p1,n=this.p2,i=this.p3;t.moveTo(e[0],e[1]),t.bezierCurveTo(s[0],s[1],n[0],n[1],i[0],i[1])}}function l(t,e){const s=e.p1[0]-e.p0[0],n=e.p1[1]-e.p0[1];return((t[0]-e.p0[0])*s+(t[1]-e.p0[1])*n)/(s*s+n*n)}function c(t,e,s){const n=t.geo,i=t.p0,r=t.p1,h=e.p0,a=e.p1,c=r[0]-i[0],u=r[1]-i[1],p=a[0]-h[0],d=a[1]-h[1],g=c*d-u*p;if(0===n.snap0(g)){if(!n.isCollinear(i,r,h))return null;const s=l(e.p0,t),o=l(e.p1,t),a=n.snap01(Math.min(s,o)),c=n.snap01(Math.max(s,o));if(c<0||a>1)return null;const u=l(t.p0,e),p=l(t.p1,e),d=n.snap01(Math.min(u,p)),g=n.snap01(Math.max(u,p));return g<0||d>1?null:{kind:"tRangePairs",tStart:[Math.max(0,a),Math.max(0,d)],tEnd:[Math.min(1,c),Math.min(1,g)]}}const f=i[0]-h[0],m=i[1]-h[1];return new o(s,n).add((p*m-d*f)/g,(c*m-u*f)/g).done()}function u(t,e,s,n){const i=t.geo,r=t.p0,h=t.p1,a=h[1]-r[1],l=r[0]-h[0],c=a*r[0]+l*r[1],u=e.getCubicCoefficients(0),p=e.getCubicCoefficients(1),d=i.solveCubic(a*u[0]+l*p[0],a*u[1]+l*p[1],a*u[2]+l*p[2],a*u[3]+l*p[3]-c),g=new o(s,i);if(0===i.snap0(a))for(const t of d){const e=u[0]*t*t*t+u[1]*t*t+u[2]*t+u[3],s=(r[0]-e)/l;n?g.add(t,s):g.add(s,t)}else for(const t of d){const e=(p[0]*t*t*t+p[1]*t*t+p[2]*t+p[3]-r[1])/a;n?g.add(t,e):g.add(e,t)}return g.done()}function p(t,e,s){const n=t.geo;if(n.isEqualVec2(t.p0,e.p0))return n.isEqualVec2(t.p3,e.p3)?n.isEqualVec2(t.p1,e.p1)&&n.isEqualVec2(t.p2,e.p2)?{kind:"tRangePairs",tStart:[0,0],tEnd:[1,1]}:{kind:"tValuePairs",tValuePairs:[[0,0],[1,1]]}:{kind:"tValuePairs",tValuePairs:[[0,0]]};if(n.isEqualVec2(t.p0,e.p3))return{kind:"tValuePairs",tValuePairs:[[0,1]]};if(n.isEqualVec2(t.p3,e.p0))return{kind:"tValuePairs",tValuePairs:[[1,0]]};if(n.isEqualVec2(t.p3,e.p3))return{kind:"tValuePairs",tValuePairs:[[1,1]]};const i=new o(s,n),r=(t,e,s,o,h,a)=>{if(!function(t,e){const[s,n]=t,[i,o]=e;return!(s[0]>o[0]||n[0]<i[0]||s[1]>o[1]||n[1]<i[1])}(t.boundingBox(),o.boundingBox()))return;const l=(e+s)/2,c=(h+a)/2;if(0===n.snap0(s-e)&&0===n.snap0(a-h))return void i.add(l,c);const[u,p]=t.split([.5]),[d,g]=o.split([.5]);r(u,e,l,d,h,c),r(p,l,s,d,h,c),r(u,e,l,g,c,a),r(p,l,s,g,c,a)};return r(t,0,1,e,0,1),i.done()}function d(t,e,s){if(t instanceof h){if(e instanceof h)return c(t,e,s);if(e instanceof a)return u(t,e,s,!1)}else if(t instanceof a){if(e instanceof h)return u(e,t,s,!0);if(e instanceof a)return p(t,e,s)}throw new Error("PolyBool: Unknown segment instance in segmentsIntersect")}class g{constructor(t,e=null,s=null){var n,i,o;this.otherFill=null,this.id=null!==(n=null==s?void 0:s.segmentId())&&void 0!==n?n:-1,this.data=t,this.myFill={above:null!==(i=null==e?void 0:e.above)&&void 0!==i?i:null,below:null!==(o=null==e?void 0:e.below)&&void 0!==o?o:null}}}class f extends g{}class m extends g{}function v(t,e){if(t instanceof f)return new f(t.data,t.myFill,e);if(t instanceof m)return new m(t.data,t.myFill,e);throw new Error("PolyBool: Unknown SegmentBool in copySegmentBool")}class w{constructor(t,e,s,n){this.status=null,this.isStart=t,this.p=e,this.seg=s,this.primary=n}}class b{constructor(){this.nodes=[]}remove(t){const e=this.nodes.indexOf(t);e>=0&&this.nodes.splice(e,1)}getIndex(t){return this.nodes.indexOf(t)}isEmpty(){return this.nodes.length<=0}getHead(){return this.nodes[0]}removeHead(){this.nodes.shift()}insertBefore(t,e){this.findTransition(t,e).insert(t)}findTransition(t,e){var s,n;let i=0,o=this.nodes.length;for(;i<o;){const s=i+o>>1;r=this.nodes[s],e(t)-e(r)>0?o=s:i=s+1}var r;return{before:i<=0?null:null!==(s=this.nodes[i-1])&&void 0!==s?s:null,after:null!==(n=this.nodes[i])&&void 0!==n?n:null,insert:t=>(this.nodes.splice(i,0,t),t)}}}class y{constructor(t,e,s=null){this.events=new b,this.status=new b,this.selfIntersection=t,this.geo=e,this.log=s}compareEvents(t,e,s,n,i,o,r,a){const l=this.geo.compareVec2(e,o);return 0!==l?l:n instanceof h&&a instanceof h&&this.geo.isEqualVec2(s,r)?0:t!==i?t?1:-1:this.compareSegments(a,n)}addEvent(t){this.events.insertBefore(t,(e=>e===t?0:this.compareEvents(t.isStart,t.p,t.other.p,t.seg.data,e.isStart,e.p,e.other.p,e.seg.data)))}divideEvent(t,e,s){var n,i;null===(n=this.log)||void 0===n||n.segmentDivide(t.seg,s);const[o,r]=t.seg.data.split([e]);o.setEnd(s),r.setStart(s);const l=r instanceof h?new f(r,t.seg.myFill,this.log):r instanceof a?new m(r,t.seg.myFill,this.log):null;if(!l)throw new Error("PolyBool: Unknown segment data in divideEvent");return this.events.remove(t.other),t.seg.data=o,null===(i=this.log)||void 0===i||i.segmentChop(t.seg),t.other.p=s,this.addEvent(t.other),this.addSegment(l,t.primary)}addSegment(t,e){const s=new w(!0,t.data.start(),t,e),n=new w(!1,t.data.end(),t,e);return s.other=n,n.other=s,this.addEvent(s),this.addEvent(n),s}addLine(t,e,s=!0){const n=this.geo.compareVec2(t,e);0!==n&&this.addSegment(new f(new h(n<0?t:e,n<0?e:t,this.geo),null,this.log),s)}addCurve(t,e,s,n,i=!0){const o=new a(t,e,s,n,this.geo),r=o.split(o.inflectionTValues());for(const t of r){const e=this.geo.compareVec2(t.start(),t.end());if(0===e)continue;const s=t.toLine();s?this.addLine(s.p0,s.p1,i):this.addSegment(new m(e<0?t:t.reverse(),null,this.log),i)}}addRegion(t){let e,s=t[t.length-1];for(let n=0;n<t.length;n++){e=s,s=t[n];const i=this.geo.compareVec2(e,s);0!==i&&this.addSegment(new f(new h(i<0?e:s,i<0?s:e,this.geo),null,this.log),!0)}}compareSegments(t,e){let s=t.start(),n=e.start2();const i=e.start();if(e.pointOn(s)){if(s=t.start2(),t instanceof h&&e instanceof h&&e.pointOn(s))return 0;if(e instanceof a&&0===this.geo.snap0(s[0]-i[0])&&0===this.geo.snap0(n[0]-i[0]))return Math.sign(i[1]-s[1])}else{if(e instanceof a){const t=e.mapXtoY(s[0],!0);if(!1!==t)return Math.sign(t-s[1])}if(t instanceof a){const s=d(t,e,!0);if(s&&"tValuePairs"===s.kind)for(const e of s.tValuePairs){const s=this.geo.snap01(e[0]);if(s>0&&s<1){n=t.point(s);break}}}}const[o,r]=s,[l,c]=n,[u,p]=i;return Math.sign((l-o)*(p-r)-(c-r)*(u-o))}statusFindSurrounding(t){return this.status.findTransition(t,(e=>{if(t===e)return 0;const s=this.compareSegments(t.seg.data,e.seg.data);return 0===s?-1:s}))}checkIntersection(t,e){var s;const n=t.seg,i=e.seg;null===(s=this.log)||void 0===s||s.checkIntersection(n,i);const o=d(n.data,i.data,!1);if(null===o)return null;if("tRangePairs"===o.kind){const{tStart:[s,r],tEnd:[h,a]}=o;if(1===s&&1===h&&0===r&&0===a||0===s&&0===h&&1===r&&1===a)return null;if(0===s&&1===h&&0===r&&1===a)return e;const l=n.data.start(),c=n.data.end(),u=i.data.end();return 0===s&&0===r?(1===h?this.divideEvent(e,a,c):this.divideEvent(t,h,u),e):(r>0&&r<1&&(1===h&&1===a||(1===h?this.divideEvent(e,a,c):this.divideEvent(t,h,u)),this.divideEvent(e,r,l)),null)}if("tValuePairs"===o.kind){if(o.tValuePairs.length<=0)return null;let s=o.tValuePairs[0];for(let t=1;t<o.tValuePairs.length&&(0===s[0]&&0===s[1]||0===s[0]&&1===s[1]||1===s[0]&&0===s[1]||1===s[0]&&1===s[1]);t++)s=o.tValuePairs[t];const[r,h]=s,a=0===h?i.data.start():1===h?i.data.end():0===r?n.data.start():1===r?n.data.end():n.data.point(r);return r>0&&r<1&&this.divideEvent(t,r,a),h>0&&h<1&&this.divideEvent(e,h,a),null}throw new Error("PolyBool: Unknown intersection type")}calculate(){var t,e,s,n,i,o,r,h;const a=[];for(;!this.events.isEmpty();){const h=this.events.getHead();if(null===(t=this.log)||void 0===t||t.vert(h.p[0]),h.isStart){null===(e=this.log)||void 0===e||e.segmentNew(h.seg,h.primary);const t=this.statusFindSurrounding(h),r=t.before,a=t.after;null===(s=this.log)||void 0===s||s.tempStatus(h.seg,!!r&&r.seg,!!a&&a.seg);const l=()=>{if(r){const t=this.checkIntersection(h,r);if(t)return t}return a?this.checkIntersection(h,a):null},c=l();if(c){if(this.selfIntersection){let t;t=null===h.seg.myFill.below||h.seg.myFill.above!==h.seg.myFill.below,t&&(c.seg.myFill.above=!c.seg.myFill.above)}else c.seg.otherFill=h.seg.myFill;null===(n=this.log)||void 0===n||n.segmentUpdate(c.seg),this.events.remove(h.other),this.events.remove(h)}if(this.events.getHead()!==h){null===(i=this.log)||void 0===i||i.rewind(h.seg);continue}if(this.selfIntersection){let t;t=null===h.seg.myFill.below||h.seg.myFill.above!==h.seg.myFill.below,h.seg.myFill.below=!!a&&a.seg.myFill.above,h.seg.myFill.above=t?!h.seg.myFill.below:h.seg.myFill.below}else if(null===h.seg.otherFill){let t;if(a)if(h.primary===a.primary){if(null===a.seg.otherFill)throw new Error("PolyBool: Unexpected state of otherFill (null)");t=a.seg.otherFill.above}else t=a.seg.myFill.above;else t=!1;h.seg.otherFill={above:t,below:t}}null===(o=this.log)||void 0===o||o.status(h.seg,!!r&&r.seg,!!a&&a.seg),h.other.status=t.insert(h)}else{const t=h.status;if(null===t)throw new Error("PolyBool: Zero-length segment detected; your epsilon is probably too small or too large");const e=this.status.getIndex(t);if(e>0&&e<this.status.nodes.length-1){const t=this.status.nodes[e-1],s=this.status.nodes[e+1];this.checkIntersection(t,s)}if(null===(r=this.log)||void 0===r||r.statusRemove(t.seg),this.status.remove(t),!h.primary){if(!h.seg.otherFill)throw new Error("PolyBool: Unexpected state of otherFill (null)");const t=h.seg.myFill;h.seg.myFill=h.seg.otherFill,h.seg.otherFill=t}a.push(h.seg)}this.events.removeHead()}return null===(h=this.log)||void 0===h||h.done(),a}}function P(t,e,s){const n=[];for(const i of t){const t=(i.myFill.above?8:0)+(i.myFill.below?4:0)+(i.otherFill&&i.otherFill.above?2:0)+(i.otherFill&&i.otherFill.below?1:0);if(0!==e[t]){const o={above:1===e[t],below:2===e[t]};if(i instanceof f)n.push(new f(i.data,o,s));else{if(!(i instanceof m))throw new Error("PolyBool: Unknown SegmentBool type in SegmentSelector");n.push(new m(i.data,o,s))}}}return null==s||s.selected(n),n}class S{static union(t,e){return P(t,[0,2,1,0,2,2,0,0,1,0,1,0,0,0,0,0],e)}static intersect(t,e){return P(t,[0,0,0,0,0,2,0,2,0,0,1,1,0,2,1,0],e)}static difference(t,e){return P(t,[0,0,0,0,2,0,2,0,1,1,0,0,0,1,2,0],e)}static differenceRev(t,e){return P(t,[0,2,1,0,0,0,1,1,0,2,0,2,0,0,0,0],e)}static xor(t,e){return P(t,[0,2,1,0,2,0,0,1,1,0,0,2,0,1,2,0],e)}}function M(t,e,s){return t!==e&&(t instanceof h&&e instanceof h?function(t,e,s){return!!s.isCollinear(t.p0,t.p1,e.p1)&&new h(t.p0,e.p1,s)}(t,e,s):t instanceof a&&e instanceof a&&function(t,e,s){if(s.isCollinear(t.p2,t.p3,e.p1)){const n=e.p1[0]-t.p2[0],i=e.p1[1]-t.p2[1],o=Math.abs(n)>Math.abs(i)?(t.p3[0]-t.p2[0])/n:(t.p3[1]-t.p2[1])/i,r=s.snap01(o);if(0!==r&&1!==r)return new a(t.p0,[t.p0[0]+(t.p1[0]-t.p0[0])/o,t.p0[1]+(t.p1[1]-t.p0[1])/o],[e.p2[0]-o*(e.p3[0]-e.p2[0])/(1-o),e.p2[1]-o*(e.p3[1]-e.p2[1])/(1-o)],e.p3,s)}return!1}(t,e,s))}function V(t,e,s,n){const i=[],o=[];for(const r of t){let l=r.data;const c=l.start(),u=l.end();if(l instanceof h&&s.isEqualVec2(c,u)){console.warn("PolyBool: Warning: Zero-length segment detected; your epsilon is probably too small or too large");continue}null==n||n.chainStart(l);const p={index:0,matchesHead:!1,matchesPt1:!1},d={index:0,matchesHead:!1,matchesPt1:!1};let g=p;function f(t,e,s){return g&&(g.index=t,g.matchesHead=e,g.matchesPt1=s),g===p?(g=d,!1):(g=null,!0)}for(let m=0;m<i.length;m++){const v=i[m],w=v[0].start(),b=v[v.length-1].end();if(s.isEqualVec2(w,c)){if(f(m,!0,!0))break}else if(s.isEqualVec2(w,u)){if(f(m,!0,!1))break}else if(s.isEqualVec2(b,c)){if(f(m,!1,!0))break}else if(s.isEqualVec2(b,u)&&f(m,!1,!1))break}if(g===p)null==n||n.chainNew(l),i.push([l]);else if(g===d){const y=p.index;null==n||n.chainMatch(y);const P=i[y];if(p.matchesHead?p.matchesPt1?(l=l.reverse(),null==n||n.chainAddHead(y,l),P.unshift(l)):(null==n||n.chainAddHead(y,l),P.unshift(l)):p.matchesPt1?(null==n||n.chainAddTail(y,l),P.push(l)):(l=l.reverse(),null==n||n.chainAddTail(y,l),P.push(l)),p.matchesHead){const E=P[1],x=M(l,E,s);x&&(null==n||n.chainSimplifyHead(y,x),P.shift(),P[0]=x)}else{const F=M(P[P.length-2],l,s);F&&(null==n||n.chainSimplifyTail(y,F),P.pop(),P[P.length-1]=F)}const S=P[0],V=P[P.length-1];if(P.length>0&&s.isEqualVec2(S.start(),V.end())){const C=M(V,S,s);C&&(null==n||n.chainSimplifyClose(y,C),P.pop(),P[0]=C),null==n||n.chainClose(y),i.splice(y,1),o.push(P)}}else{function T(t){null==n||n.chainReverse(t);const e=[];for(const s of i[t])e.unshift(s.reverse());i[t]=e}function k(t,e){const o=i[t],r=i[e];null==n||n.chainAddTail(t,l),o.push(l);const h=M(o[o.length-2],l,s);h&&(null==n||n.chainSimplifyTail(t,h),o.pop(),o[o.length-1]=h);const a=M(o[o.length-1],r[0],s);a&&(null==n||n.chainSimplifyJoin(t,e,a),r.shift(),o[o.length-1]=a),null==n||n.chainJoin(t,e),i[t]=o.concat(r),i.splice(e,1)}const I=p.index,B=d.index;null==n||n.chainConnect(I,B);const q=i[I].length<i[B].length;p.matchesHead?d.matchesHead?q?(p.matchesPt1||(l=l.reverse()),T(I),k(I,B)):(p.matchesPt1&&(l=l.reverse()),T(B),k(B,I)):(p.matchesPt1&&(l=l.reverse()),k(B,I)):d.matchesHead?(p.matchesPt1||(l=l.reverse()),k(I,B)):q?(p.matchesPt1&&(l=l.reverse()),T(I),k(B,I)):(p.matchesPt1||(l=l.reverse()),T(B),k(I,B))}}for(const _ of o){e.beginPath();for(let R=0;R<_.length;R++){const H=_[R];if(0===R){const O=H.start();e.moveTo(O[0],O[1])}if(H instanceof h)e.lineTo(H.p1[0],H.p1[1]);else{if(!(H instanceof a))throw new Error("PolyBool: Unknown segment instance");e.bezierCurveTo(H.p1[0],H.p1[1],H.p2[0],H.p2[1],H.p3[0],H.p3[1])}}e.closePath()}}class E{constructor(t,e,s=null){this.pathState={kind:"beginPath"},this.geo=e,this.log=s,this.resultState=t?{final:!0,segments:t}:{final:!1,selfIntersect:new y(!0,this.geo,this.log)}}beginPath(){return this.endPath()}moveTo(t,e){if(this.resultState.final)throw new Error("PolyBool: Cannot change shape after using it in an operation");"beginPath"!==this.pathState.kind&&this.beginPath();const s=[t,e];return this.pathState={kind:"moveTo",start:s,current:s},this}lineTo(t,e){if(this.resultState.final)throw new Error("PolyBool: Cannot change shape after using it in an operation");if("moveTo"!==this.pathState.kind)throw new Error("PolyBool: Must call moveTo prior to calling lineTo");const s=[t,e];return this.resultState.selfIntersect.addLine(this.pathState.current,s),this.pathState.current=s,this}bezierCurveTo(t,e,s,n,i,o){if(this.resultState.final)throw new Error("PolyBool: Cannot change shape after using it in an operation");if("moveTo"!==this.pathState.kind)throw new Error("PolyBool: Must call moveTo prior to calling bezierCurveTo");const r=[i,o];return this.resultState.selfIntersect.addCurve(this.pathState.current,[t,e],[s,n],r),this.pathState.current=r,this}closePath(){if(this.resultState.final)throw new Error("PolyBool: Cannot change shape after using it in an operation");return"moveTo"!==this.pathState.kind||this.geo.isEqualVec2(this.pathState.start,this.pathState.current)||this.lineTo(this.pathState.start[0],this.pathState.start[1]),this.endPath()}endPath(){if(this.resultState.final)throw new Error("PolyBool: Cannot change shape after using it in an operation");return this.pathState={kind:"beginPath"},this}selfIntersect(){return this.resultState.final||(this.resultState={final:!0,segments:this.resultState.selfIntersect.calculate()}),this.resultState.segments}output(t){return V(this.selfIntersect(),t,this.geo,this.log),t}combine(t){const e=new y(!1,this.geo,this.log);for(const t of this.selfIntersect())e.addSegment(v(t,this.log),!0);for(const s of t.selfIntersect())e.addSegment(v(s,this.log),!1);return new x(e.calculate(),this.geo,this.log)}}class x{constructor(t,e,s=null){this.geo=e,this.segments=t,this.log=s}union(){return new E(S.union(this.segments,this.log),this.geo,this.log)}intersect(){return new E(S.intersect(this.segments,this.log),this.geo,this.log)}difference(){return new E(S.difference(this.segments,this.log),this.geo,this.log)}differenceRev(){return new E(S.differenceRev(this.segments,this.log),this.geo,this.log)}xor(){return new E(S.xor(this.segments,this.log),this.geo,this.log)}}class F{constructor(){this.list=[],this.nextSegmentId=0,this.curVert=NaN}push(t,e){this.list.push({type:t,data:JSON.parse(JSON.stringify(e))})}info(t,e){this.push("info",{msg:t,data:e})}segmentId(){return this.nextSegmentId++}checkIntersection(t,e){this.push("check",{seg1:t,seg2:e})}segmentDivide(t,e){this.push("div_seg",{seg:t,p:e})}segmentChop(t){this.push("chop",{seg:t})}statusRemove(t){this.push("pop_seg",{seg:t})}segmentUpdate(t){this.push("seg_update",{seg:t})}segmentNew(t,e){this.push("new_seg",{seg:t,primary:e})}tempStatus(t,e,s){this.push("temp_status",{seg:t,above:e,below:s})}rewind(t){this.push("rewind",{seg:t})}status(t,e,s){this.push("status",{seg:t,above:e,below:s})}vert(t){t!==this.curVert&&(this.push("vert",{x:t}),this.curVert=t)}selected(t){this.push("selected",{segs:t})}chainStart(t){this.push("chain_start",{seg:t})}chainNew(t){this.push("chain_new",{seg:t})}chainMatch(t){this.push("chain_match",{index:t})}chainClose(t){this.push("chain_close",{index:t})}chainAddHead(t,e){this.push("chain_add_head",{index:t,seg:e})}chainAddTail(t,e){this.push("chain_add_tail",{index:t,seg:e})}chainSimplifyHead(t,e){this.push("chain_simp_head",{index:t,seg:e})}chainSimplifyTail(t,e){this.push("chain_simp_tail",{index:t,seg:e})}chainSimplifyClose(t,e){this.push("chain_simp_close",{index:t,seg:e})}chainSimplifyJoin(t,e,s){this.push("chain_simp_join",{index1:t,index2:e,seg:s})}chainConnect(t,e){this.push("chain_con",{index1:t,index2:e})}chainReverse(t){this.push("chain_rev",{index:t})}chainJoin(t,e){this.push("chain_join",{index1:t,index2:e})}done(){this.push("done",null)}}class C{constructor(t=new n,e=null){this.geo=t,this.log=e}shape(){return new E(null,this.geo,this.log)}buildLog(t){var e;return this.log=t?new F:null,null===(e=this.log)||void 0===e?void 0:e.list}segments(t){const e=this.shape();for(const s of t.regions){e.beginPath();const t=s[s.length-1];e.moveTo(t[t.length-2],t[t.length-1]);for(const t of s)if(2===t.length)e.lineTo(t[0],t[1]);else{if(6!==t.length)throw new Error("PolyBool: Invalid point in region");e.bezierCurveTo(t[0],t[1],t[2],t[3],t[4],t[5])}e.closePath()}return{shape:e,inverted:t.inverted}}combine(t,e){return{shape:t.shape.combine(e.shape),inverted1:t.inverted,inverted2:e.inverted}}selectUnion(t){return{shape:t.inverted1?t.inverted2?t.shape.intersect():t.shape.difference():t.inverted2?t.shape.differenceRev():t.shape.union(),inverted:t.inverted1||t.inverted2}}selectIntersect(t){return{shape:t.inverted1?t.inverted2?t.shape.union():t.shape.differenceRev():t.inverted2?t.shape.difference():t.shape.intersect(),inverted:t.inverted1&&t.inverted2}}selectDifference(t){return{shape:t.inverted1?t.inverted2?t.shape.differenceRev():t.shape.union():t.inverted2?t.shape.intersect():t.shape.difference(),inverted:t.inverted1&&!t.inverted2}}selectDifferenceRev(t){return{shape:t.inverted1?t.inverted2?t.shape.difference():t.shape.intersect():t.inverted2?t.shape.union():t.shape.differenceRev(),inverted:!t.inverted1&&t.inverted2}}selectXor(t){return{shape:t.shape.xor(),inverted:t.inverted1!==t.inverted2}}polygon(t){const e=[],s={beginPath:()=>{e.push([])},moveTo:()=>{},lineTo:(t,s)=>{e[e.length-1].push([t,s])},bezierCurveTo:(t,s,n,i,o,r)=>{e[e.length-1].push([t,s,n,i,o,r])},closePath:()=>{}};return t.shape.output(s),{regions:e,inverted:t.inverted}}union(t,e){const s=this.segments(t),n=this.segments(e),i=this.combine(s,n),o=this.selectUnion(i);return this.polygon(o)}intersect(t,e){const s=this.segments(t),n=this.segments(e),i=this.combine(s,n),o=this.selectIntersect(i);return this.polygon(o)}difference(t,e){const s=this.segments(t),n=this.segments(e),i=this.combine(s,n),o=this.selectDifference(i);return this.polygon(o)}differenceRev(t,e){const s=this.segments(t),n=this.segments(e),i=this.combine(s,n),o=this.selectDifferenceRev(i);return this.polygon(o)}xor(t,e){const s=this.segments(t),n=this.segments(e),i=this.combine(s,n),o=this.selectXor(i);return this.polygon(o)}}const T=new C;export{F as BuildLog,n as GeometryEpsilon,y as Intersecter,C as PolyBool,r as SegmentBase,V as SegmentChainer,a as SegmentCurve,h as SegmentLine,S as SegmentSelector,o as SegmentTValuePairsBuilder,i as SegmentTValuesBuilder,E as Shape,x as ShapeCombined,T as default,l as projectPointOntoSegmentLine,p as segmentCurveIntersectSegmentCurve,u as segmentLineIntersectSegmentCurve,c as segmentLineIntersectSegmentLine,d as segmentsIntersect};
